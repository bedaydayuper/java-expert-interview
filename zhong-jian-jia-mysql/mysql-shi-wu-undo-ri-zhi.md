# MySQL 事务-undo日志



## 1 事务回滚的需求

### 1.1 回滚

事务执行过程中可能已经修改了很多东西，为了保证事务的原子性，我们需要把东西改回原先的样子，这个过程就称之为`回滚`

每当我们要对一条记录做改动时（这里的`改动`可以指`INSERT`、`DELETE`、`UPDATE`），都需要留一手 —— 把回滚时所需的东西都给记下来

### 1.2 undo 日志

为了回滚而记录的这些东东称之为撤销日志。

## 2 事务id

### 2.1 给事务分配id 的时机

1、只读事务

对于只读事务来说，只有在它第一次对某个用户创建的临时表执行增、删、改操作时才会为这个事务分配一个`事务id`，否则的话是不分配`事务id`的。

2、读写事务

对于读写事务来说，只有在它第一次对某个表（包括用户创建的临时表）执行增、删、改操作时才会为这个事务分配一个`事务id`，否则的话也是不分配`事务id`的。

只有在事务对表中的记录做改动时才会为这个事务分配一个唯一的`事务id`。

### 2.2 事务id是怎么生成的

```text
具体策略如下：
​
服务器会在内存中维护一个全局变量，每当需要为某个事务分配一个事务id时，就会把该变量的值当作事务id分配给该事务，并且把该变量自增1。
​
每当这个变量的值为256的倍数时，就会将该变量的值刷新到系统表空间的页号为5的页面中一个称之为Max Trx ID的属性处，这个属性占用8个字节的存储空间。
​
当系统下一次重新启动时，会将上边提到的Max Trx ID属性加载到内存中，将该值加上256之后赋值给我们前边提到的全局变量（因为在上次关机时该全局变量的值可能大于Max Trx ID属性值）。
```

## 3 undo 日志的格式

### 3.1 insert 的undo 日志

![](../.gitbook/assets/image%20%28181%29.png)

#### 3.1.1 疑问

插入时，为什么没有记录有关 索引的undo 日志呢？？？？？？？

### 3.2 DELETE操作对应的undo日志

被删除的记录其实也会根据记录头信息中的`next_record`属性组成一个链表，只不过这个链表中的记录占用的存储空间可以被重新利用，所以也称这个链表为`垃圾链表`

![](../.gitbook/assets/image%20%28187%29.png)

删除的两个阶段：

```text
阶段一：仅仅将记录的`delete_mask`标识位设置为`1`，其他的不做修改（其实会修改记录的`trx_id`、`roll_pointer`这些隐藏列的值）。设计`InnoDB`的大叔把这个阶段称之为`delete mark`。
​
阶段二：当该删除语句所在的事务提交之后，会有专门的线程后来真正的把记录删除掉。所谓真正的删除就是把该记录从`正常记录链表`中移除，并且加入到`垃圾链表`中，然后还要调整一些页面的其他信息，比如页面中的用户记录数量`PAGE_N_RECS`、上次插入记录的位置`PAGE_LAST_INSERT`、垃圾链表头节点的指针`PAGE_FREE`、页面中可重用的字节数量`PAGE_GARBAGE`、还有页目录的一些信息等等。设计`InnoDB`的大叔把这个阶段称之为`purge`。
​
把`阶段二`执行完了，这条记录就算是真正的被删除掉了。这条已删除记录占用的存储空间也可以被重新利用了。

```

![](../.gitbook/assets/image%20%28185%29.png)

删除日志的注意事项：

```text
1、在对一条记录进行delete mark操作前，需要把该记录的旧的trx_id和roll_pointer隐藏列的值都给记到对应的undo日志中来，就是我们图中显示的old trx_id和old roll_pointer属性。这样有一个好处，那就是可以通过undo日志的old roll_pointer找到记录在修改之前对应的undo日志。
2、如果某个列被包含在某个索引中，那么它的相关信息就应该被记录到这个索引列各列信息部分，所谓的相关信息包括该列在记录中的位置
​
```

### 3.3 UPDATE操作对应的undo日志

#### 3.3.1 不更新主键

**3.3.1.1 就地更新**

更新记录时，对于被更新的每个列来说，如果更新后的列和更新前的列占用的存储空间都一样大，那么就可以进行`就地更新`，也就是直接在原记录的基础上修改对应列的值。

**3.3.1.2 先删除掉旧记录，再插入新记录**

在不更新主键的情况下，如果有任何一个被更新的列更新前和更新后占用的存储空间大小不一致，那么就需要先把这条旧的记录从聚簇索引页面中删除掉，然后再根据更新后列的值创建一条新的记录插入到页面中。

![](../.gitbook/assets/image%20%28183%29.png)

#### 3.3.2 更新主键

1、更新主键的步骤：

```text
(1) 将旧记录进行delete mark操作
​
​
(2)根据更新后各列的值创建一条新记录，并将其插入到聚簇索引中（需重新定位插入的位置）。
```

## 4 通用链表结构

### 4.1 List node 结构示意图

![](../.gitbook/assets/image%20%28189%29.png)

### 4.2 基节点

![](../.gitbook/assets/image%20%28188%29.png)

list length 记录链表总共有多少节点

first node : 记录 首节点。

last node 记录 链表尾结点。

## 5 FIL\_PAGE\_UNDO\_LOG页面

1、用来存储undo 日志的页。

![](../.gitbook/assets/image%20%28182%29.png)

2、 undo page header

![](../.gitbook/assets/image%20%28186%29.png)

trx\_undo\_page\_type: 类型

trx\_undo\_page\_start: 从什么位置开始存储undo 日志。

trx\_undo\_page\_free: 表示当前页面中存储的最后一条undo 结束时的偏移量。

## 6 Undo页面链表

### 6.1 单个事务的undo 页面链表

一个事务可能包含多条语句，而且一个语句可能对应若干记录进行改动，而对每天记录进行改动前，都需要记录1、2条undo 日志，所以一个事务执行过程中可能会产生很多undo 日志。这些日志可能一个页面放不下，需要放到多个页面中。

并且undo 日志需要按照执行类型划分为不同的链表。

![](../.gitbook/assets/image%20%28184%29.png)

具体的分配策略：按需分配。

```text
刚刚开启事务时，一个Undo页面链表也不分配。
​
当事务执行过程中向普通表中插入记录或者执行更新记录主键的操作之后，就会为其分配一个普通表的insert undo链表。
​
当事务执行过程中删除或者更新了普通表中的记录之后，就会为其分配一个普通表的update undo链表。
​
当事务执行过程中向临时表中插入记录或者执行更新记录主键的操作之后，就会为其分配一个临时表的insert undo链表。
​
当事务执行过程中删除或者更新了临时表中的记录之后，就会为其分配一个临时表的update undo链表。
​
​
```

### 6.2 多个事务的undo页面链表

为了尽可能提高`undo日志`的写入效率，不同事务执行过程中产生的undo日志需要被写入到不同的Undo页面链表中。

![](../.gitbook/assets/image%20%28190%29.png)

## 7 undo 日志具体写入过程

### 7.1 段的概念

![](../.gitbook/assets/image%20%28180%29.png)

```text
Space ID of the INODE Entry：INODE Entry结构所在的表空间ID。
​
Page Number of the INODE Entry：INODE Entry结构所在的页面页号。
​
Byte Offset of the INODE Ent：INODE Entry结构在该页面中的偏移量
```

### 7.2 undo log segment header

每一个`Undo页面`链表都对应着一个`段`，称之为`Undo Log Segment`

这个段的链表中，第一个页面，称为 undo log segment header 。

### 7.3 undo log header

一个事务在向`Undo页面`中写入`undo日志`时的方式是十分简单暴力的，就是直接往里怼，写完一条紧接着写另一条，各条`undo日志`之间是亲密无间的。写完一个`Undo页面`后，再从段里申请一个新页面，然后把这个页面插入到`Undo页面`链表中，继续往这个新申请的页面中写。

## 8 重用undo 页面

```text
为了能提高并发执行的多个事务写入undo日志的性能，设计InnoDB的大叔决定为每个事务单独分配相应的Undo页面链表（最多可能单独分配4个链表）。但是这样也造成了一些问题，比如其实大部分事务执行过程中可能只修改了一条或几条记录，针对某个Undo页面链表只产生了非常少的undo日志，这些undo日志可能只占用一丢丢存储空间，每开启一个事务就新创建一个Undo页面链表（虽然这个链表中只有一个页面）来存储这么一丢丢undo日志岂不是太浪费了么？的确是挺浪费，于是设计InnoDB的大叔本着勤俭节约的优良传统，决定在事务提交后在某些情况下重用该事务的Undo页面链表。
```

