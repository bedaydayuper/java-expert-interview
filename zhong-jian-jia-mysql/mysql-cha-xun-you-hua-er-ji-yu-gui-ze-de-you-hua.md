# MySQL 查询优化（二）基于规则的优化

## 1 条件化简

### 1.1 移除不必要的括号

主要是把表示优先级 而增加的一些括号 去掉。

### 1.2 常量传递（constant\_propagation）

某个表达式是某个列\(比如 a\)和某个常量做等值\(比如1\)匹配, 当这个表达式和其他涉及列`a`的表达式使用`AND`连接起来时，可以将其他表达式中的`a`的值替换为`1`

比如

```text
a = 5 and b > a 
```

会 改造成 

```text
a = 5 and b > 5.
```



### 1.3 等值传递（equality\_propagation）

多个列之间存在等值匹配的关系

比如：

```text
a = b and b = c and c = 5
```

会改造成

```text
a = 5 and b = 5 and c = 5
```

### 1.4 移除没用的条件（trivial\_condition\_removal）

对于一些明显永远为`TRUE`或者`FALSE`的表达式，优化器会移除掉它们。



### 1.5 表达式计算

如果表达式中只包含常量的话，它的值会被先计算出来

比如

```text
a = 5 + 1
```

会转化为

```text
a = 6
```

\*\*只有搜索条件中索引列和常数使用某些运算符连接起来才可能使用到索引，所以如果可以的话，最好让索引列以单独的形式出现在表达式中 \*\*



### 1.6 HAVING子句和WHERE子句的合并

如果查询语句中没有出现诸如`SUM`、`MAX`等等的聚集函数以及`GROUP BY`子句，优化器就把`HAVING`子句和`WHERE`子句合并起来。

### 1.7 常量表检测 

使用主键等值匹配或者唯一二级索引列等值匹配作为搜索条件来查询某个表 时，性能比较好，也成为 常量表。

优化器在分析一个查询语句时，先首先执行常量表查询，然后把查询中涉及到该表的条件全部替换成常数，最后再分析其余表的查询成本。

比如：

```text
SELECT * FROM table1 INNER JOIN table2
    ON table1.column1 = table2.column2 
    WHERE table1.primary_key = 1;
```

这个查询可以使用主键和常量值的等值匹配来查询`table1`表，也就是在这个查询中`table1`表相当于`常量表`，在分析对`table2`表的查询成本之前，就会执行对`table1`表的查询，并把查询中涉及`table1`表的条件都替换掉。

## 2 外连接消除

`内连接`的驱动表和被驱动表的位置可以相互转换，而`左（外）连接`和`右（外）连接`的驱动表和被驱动表是固定的。这就导致`内连接`可能通过优化表的连接顺序来降低整体的查询成本，而`外连接`却无法优化表的连接顺序。

### 2.1 外连接转内连接（空值拒绝）

`1、WHERE`子句的杀伤力比较大，凡是不符合WHERE子句中条件的记录都不会参与连接。只要我们在搜索条件中指定关于被驱动表相关列的值不为`NULL`，那么外连接中在被驱动表中找不到符合`ON`子句条件的驱动表记录也就被排除出最后的结果集了，也就是说：在这种情况下：外连接和内连接也就没有什么区别了

指定的`WHERE`子句中包含被驱动表中的列不为`NULL`值的条件称之为`空值拒绝`（英文名：`reject-NULL`）。在被驱动表的WHERE子句符合空值拒绝的条件后，外连接和内连接可以相互转换。这种转换带来的好处就是查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询。

## 3 子查询优化

### 3.1 子查询语法

#### 3.1.1 **按返回的结果集区分子查询**

#### \*\*\*\*

#### **1、标量子查询**

只返回一个单一值的子查询称之为`标量子查询`

**2、行子查询**

返回一条记录的子查询，不过这条记录需要包含多个列

**3、列子查询**

查询出一个列的数据喽，不过这个列的数据需要包含多条记录

**4、表子查询**

子查询的结果既包含很多条记录，又包含很多个列

\*\*\*\*

#### **3.1.2 按与外层查询关系来区分子查询**

**1、不相关子查询**

如果子查询可以单独运行出结果，而不依赖于外层查询的值，我们就可以把这个子查询称之为`不相关子查询`

**2、相关子查询**

如果子查询的执行需要依赖于外层查询的值，我们就可以把这个子查询称之为`相关子查询`

```text
SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2 WHERE n1 = n2);
```

例子中的子查询是`(SELECT m2 FROM t2 WHERE n1 = n2)`，可是这个查询中有一个搜索条件是`n1 = n2`，别忘了`n1`是表`t1`的列，也就是外层查询的列，也就是说子查询的执行需要依赖于外层查询的值，所以这个子查询就是一个`相关子查询`。

#### 3.1.3 **子查询在布尔表达式中的使用**

**1、**使用`=`、`>`、`<`、`>=`、`<=`、`<>`、`!=`、`<=>`作为布尔表达式的操作符  


2、\[NOT\] IN/ANY/SOME/ALL子查询



3、EXISTS 子查询

```text
[NOT] EXISTS (子查询)
```

### 3.2 **子查询语法注意事项**

1、子查询必须用小括号扩起来。

2、在`SELECT`子句中的子查询必须是标量子查询。  
3、在想要得到标量子查询或者行子查询，但又不能保证子查询的结果集只有一条记录时，应该使用`LIMIT 1`语句来限制记录数量。

4、对于`[NOT] IN/ANY/SOME/ALL`子查询来说，子查询中不允许有`LIMIT`语句。  
5、不允许在一条语句中增删改某个表的记录时同时还对该表进行子查询。



### 3.3 子查询在MySQL中是怎么执行的

#### 3.3.1 **标量子查询、行子查询的执行方式**

**1、**对于包含不相关的标量子查询或者行子查询的查询语句来说，MySQL会分别独立的执行外层查询和子查询

（1）先执行子查询。

（2）然后利用子查询的结构，作为外层查询的子条件，进行外层查询。

2、对于相关的标量子查询或者行子查询的步骤：

（1）先从外层查询中获取一条记录

（2）然后从上一步骤中获取的那条记录中找出子查询中涉及到的值，然后执行子查询。

（3）最后根据子查询的查询结果来检测外层查询`WHERE`子句的条件是否成立，如果成立，就把外层查询的那条记录加入到结果集，否则就丢弃。

（4）再次执行第一步，获取第二条外层查询中的记录，依次类推～

#### 3.3.2 **IN子查询优化**

1 **物化表的提出**

**1.1、如果子查询结果太多，那么会导致如下两个问题：**

\(1\) 无法有效的使用索引，只能对外层查询进行全表扫描。

\(2\) 在对外层查询执行全表扫描时，由于`IN`子句中的参数太多，这会导致检测一条记录是否符合和`IN`子句中的参数匹配花费的时间太长。

1.2 物化表

不直接将不相关查询的结果集当做完成查询的参数，而是将结果集写入一个临时表里面。写入临时表的过程是这样的：

（1）临时表中的列就是子查询结果集中的列

（2）写入临时表的记录会被去重

（3）一般情况下子查询结果集不会大的离谱，所以会为它建立基于内存的使用`Memory`存储引擎的临时表，而且会为该表建立哈希`索引`。

> 如果子查询的结果集非常大，超过了系统变量`tmp_table_size`或者`max_heap_table_size`，临时表会转而使用基于磁盘的存储引擎来保存结果集中的记录，索引类型也对应转变为`B+`树索引。



将子查询结果集中的记录保存到临时表的过程称之为`物化`

把那个存储子查询结果集的临时表称之为`物化表`

\`\`

正因为物化表中的记录都建立了索引（基于内存的物化表有哈希索引，基于磁盘的有B+树索引），通过索引执行`IN`语句判断某个操作数在不在子查询结果集中变得非常快，从而提升了子查询语句的性能。

**2、物化表转连接**

物化之后，外层表跟 物化表就是内连接了。`MySQL`查询优化器会通过运算来选择上述成本更低的方案来执行查询。  


**3、将子查询转换为semi-join（半连接）**

能不能不进行物化操作直接把子查询转换为连接呢？

将`s1`表和`s2`表进行半连接的意思就是：对于`s1`表的某条记录来说，我们只关心在`s2`表中是否存在与之匹配的记录，而不关心具体有多少条记录与之匹配，最终的结果集中只保留`s1`表的记录。

（3.1）如何实现半连接？

（1）Table pullout （子查询中的表上拉）

当子查询的查询列表处只有主键或者唯一索引列时，可以直接把子查询中的表`上拉`到外层查询的`FROM`子句中，并把子查询中的搜索条件合并到外层查询的搜索条件中

（2）DuplicateWeedout execution strategy （重复值消除）



（3）LooseScan execution strategy （松散扫描）

（4）。。。



**4、semi-join的适用条件**

```text
该子查询必须是和IN语句组成的布尔表达式，并且在外层查询的WHERE或者ON子句中出现。

外层查询也可以有其他的搜索条件，只不过和IN子查询的搜索条件必须使用AND连接起来。

该子查询必须是一个单一的查询，不能是由若干查询由UNION连接起来的形式。

该子查询不能包含GROUP BY或者HAVING语句或者聚集函数。

... 还有一些条件比较少见，就不唠叨啦～
```

**5、不适用于semi-join的情况**

暂时忽略。

6、小结一下

```text
(1) 如果IN子查询符合转换为semi-join的条件，查询优化器会优先把该子查询转换为semi-join，然后再考虑下边5种执行半连接的策略中哪个成本最低：

Table pullout
DuplicateWeedout
LooseScan
Materialization
FirstMatch
选择成本最低的那种执行策略来执行子查询。

(2) 如果IN子查询不符合转换为semi-join的条件，那么查询优化器会从下边两种策略中找出一种成本更低的方式执行子查询：

先将子查询物化之后再执行查询
执行IN to EXISTS转换。
```

#### 3.3.3  **ANY/ALL子查询优化**

如果ANY/ALL子查询是不相关子查询的话，它们在很多场合都能转换成我们熟悉的方式去执行

![](../.gitbook/assets/image%20%28171%29.png)

#### **3.3.4 \[NOT\] EXISTS子查询的执行**

如果`[NOT] EXISTS`子查询是不相关子查询，可以先执行子查询，得出该`[NOT] EXISTS`子查询的结果是`TRUE`还是`FALSE`，并重写原先的查询语句.



#### **3.3.5 对于派生表的优化**

把子查询放在外层查询的`FROM`子句后，那么这个子查询的结果相当于一个`派生表`

`1、`对于含有`派生表`的查询，`MySQL`提供了两种执行策略

（1）最容易想到的就是把派生表物化。



（2）将派生表和外层的表合并，也就是将查询重写为没有派生表的形式





\*\*\*\*

\*\*\*\*

