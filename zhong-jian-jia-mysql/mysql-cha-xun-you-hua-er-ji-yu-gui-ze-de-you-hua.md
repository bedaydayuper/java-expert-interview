# MySQL 查询优化（二）基于规则的优化

## 1 条件化简

### 1.1 移除不必要的括号

主要是把表示优先级 而增加的一些括号 去掉。

### 1.2 常量传递（constant\_propagation）

某个表达式是某个列\(比如 a\)和某个常量做等值\(比如1\)匹配, 当这个表达式和其他涉及列`a`的表达式使用`AND`连接起来时，可以将其他表达式中的`a`的值替换为`1`

比如

```text
a = 5 and b > a 
```

会 改造成 

```text
a = 5 and b > 5.
```



### 1.3 等值传递（equality\_propagation）

多个列之间存在等值匹配的关系

比如：

```text
a = b and b = c and c = 5
```

会改造成

```text
a = 5 and b = 5 and c = 5
```

### 1.4 移除没用的条件（trivial\_condition\_removal）

对于一些明显永远为`TRUE`或者`FALSE`的表达式，优化器会移除掉它们。



### 1.5 表达式计算

如果表达式中只包含常量的话，它的值会被先计算出来

比如

```text
a = 5 + 1
```

会转化为

```text
a = 6
```

\*\*只有搜索条件中索引列和常数使用某些运算符连接起来才可能使用到索引，所以如果可以的话，最好让索引列以单独的形式出现在表达式中 \*\*



### 1.6 HAVING子句和WHERE子句的合并

如果查询语句中没有出现诸如`SUM`、`MAX`等等的聚集函数以及`GROUP BY`子句，优化器就把`HAVING`子句和`WHERE`子句合并起来。

### 1.7 常量表检测 

使用主键等值匹配或者唯一二级索引列等值匹配作为搜索条件来查询某个表 时，性能比较好，也成为 常量表。

优化器在分析一个查询语句时，先首先执行常量表查询，然后把查询中涉及到该表的条件全部替换成常数，最后再分析其余表的查询成本。

比如：

```text
SELECT * FROM table1 INNER JOIN table2
    ON table1.column1 = table2.column2 
    WHERE table1.primary_key = 1;
```

这个查询可以使用主键和常量值的等值匹配来查询`table1`表，也就是在这个查询中`table1`表相当于`常量表`，在分析对`table2`表的查询成本之前，就会执行对`table1`表的查询，并把查询中涉及`table1`表的条件都替换掉。

## 2 外连接消除

`内连接`的驱动表和被驱动表的位置可以相互转换，而`左（外）连接`和`右（外）连接`的驱动表和被驱动表是固定的。这就导致`内连接`可能通过优化表的连接顺序来降低整体的查询成本，而`外连接`却无法优化表的连接顺序。

### 2.1 外连接转内连接（空值拒绝）

`1、WHERE`子句的杀伤力比较大，凡是不符合WHERE子句中条件的记录都不会参与连接。只要我们在搜索条件中指定关于被驱动表相关列的值不为`NULL`，那么外连接中在被驱动表中找不到符合`ON`子句条件的驱动表记录也就被排除出最后的结果集了，也就是说：在这种情况下：外连接和内连接也就没有什么区别了

指定的`WHERE`子句中包含被驱动表中的列不为`NULL`值的条件称之为`空值拒绝`（英文名：`reject-NULL`）。在被驱动表的WHERE子句符合空值拒绝的条件后，外连接和内连接可以相互转换。这种转换带来的好处就是查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询。

## 3 子查询优化

### 3.1 子查询语法

#### 3.1.1 **按返回的结果集区分子查询**

#### \*\*\*\*

#### **1、标量子查询**

只返回一个单一值的子查询称之为`标量子查询`

**2、行子查询**

返回一条记录的子查询，不过这条记录需要包含多个列

**3、列子查询**

查询出一个列的数据喽，不过这个列的数据需要包含多条记录

**4、表子查询**

子查询的结果既包含很多条记录，又包含很多个列

\*\*\*\*

#### **3.1.2 按与外层查询关系来区分子查询**

**1、不相关子查询**

如果子查询可以单独运行出结果，而不依赖于外层查询的值，我们就可以把这个子查询称之为`不相关子查询`

**2、相关子查询**

如果子查询的执行需要依赖于外层查询的值，我们就可以把这个子查询称之为`相关子查询`

```text
SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2 WHERE n1 = n2);
```

例子中的子查询是`(SELECT m2 FROM t2 WHERE n1 = n2)`，可是这个查询中有一个搜索条件是`n1 = n2`，别忘了`n1`是表`t1`的列，也就是外层查询的列，也就是说子查询的执行需要依赖于外层查询的值，所以这个子查询就是一个`相关子查询`。

#### 3.1.3 **子查询在布尔表达式中的使用**

**1、**使用`=`、`>`、`<`、`>=`、`<=`、`<>`、`!=`、`<=>`作为布尔表达式的操作符  


2、\[NOT\] IN/ANY/SOME/ALL子查询



3、EXISTS 子查询

```text
[NOT] EXISTS (子查询)
```

### 3.2 **子查询语法注意事项**

1、子查询必须用小括号扩起来。

2、在`SELECT`子句中的子查询必须是标量子查询。  
3、在想要得到标量子查询或者行子查询，但又不能保证子查询的结果集只有一条记录时，应该使用`LIMIT 1`语句来限制记录数量。

4、对于`[NOT] IN/ANY/SOME/ALL`子查询来说，子查询中不允许有`LIMIT`语句。  
5、不允许在一条语句中增删改某个表的记录时同时还对该表进行子查询。



### 3.3 子查询在MySQL中是怎么执行的

#### 3.3.1 **标量子查询、行子查询的执行方式**

**1、**对于包含不相关的标量子查询或者行子查询的查询语句来说，MySQL会分别独立的执行外层查询和子查询

（1）先执行子查询。

（2）然后利用子查询的结构，作为外层查询的子条件，进行外层查询。

2、对于相关的标量子查询或者行子查询的步骤：

（1）先从外层查询中获取一条记录

（2）然后从上一步骤中获取的那条记录中找出子查询中涉及到的值，然后执行子查询。

（3）最后根据子查询的查询结果来检测外层查询`WHERE`子句的条件是否成立，如果成立，就把外层查询的那条记录加入到结果集，否则就丢弃。

（4）再次执行第一步，获取第二条外层查询中的记录，依次类推～

#### 3.3.2 **IN子查询优化**

1、**物化表的提出**

\*\*\*\*

**2、物化表转连接**

\*\*\*\*

**3、将子查询转换为semi-join**

\*\*\*\*

**4、semi-join的适用条件**

\*\*\*\*

**5、不适用于semi-join的情况**

\*\*\*\*

#### 3.3.3  **ANY/ALL子查询优化**

\*\*\*\*

#### **3.3.4 \[NOT\] EXISTS子查询的执行**

\*\*\*\*

#### **3.3.5 对于派生表的优化**

\*\*\*\*

\*\*\*\*

\*\*\*\*

