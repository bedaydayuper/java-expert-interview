# MySQL基础-记录结构

## 1 InnoDB 记录存储结构

### 1.1 InnoDB 页 

一条条从磁盘读取到内存比较慢，所以使用页，以页作为磁盘与内存交互的基本单位。

### 1.2 InnoDB 行格式

1、有四种行格式：compact、redundant、dynamic、compressed。

### 1.3 compact  格式

变长列表

![](../.gitbook/assets/image%20%28143%29.png)

![](../.gitbook/assets/image%20%28153%29.png)

NULL值列表

```text
1、统计表中允许存储NULL 的列有哪些
2、如果没有允许NULL的列，则NULL值列表也就不存在了。否则允许每个允许存储NULL的列对应
一个二进制位。
3、NULL值列表必须使用整数个字节的位表示，如果不足一字节，则补齐。
```

记录头信息： 由固定的5个字节组成。

![](../.gitbook/assets/image%20%28139%29.png)

![](../.gitbook/assets/image%20%28145%29.png)

记录的真实数据

除了自定义的数据之外，MySQL会为每个记录默认的添加一些列（也成为隐藏列）。

![](../.gitbook/assets/image%20%28157%29.png)

InnoDB主键的生成策略：

```text
优先使用用户自定义主键作为主键，
如果用户没有定义主键，则选取一个Unique键作为主键，
如果表中连Unique键都没有定义的话，则InnoDB会为表默认添加一个名为row_id的隐藏列作为主键。


```

增加了隐藏列之后，行记录是这样的：

![](../.gitbook/assets/image%20%28146%29.png)

**CHAR\(M\)列的存储格式：**

对于 _**CHAR\(M\)**_ 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。

### 1.4 行溢出数据-**VARCHAR\(M\)最多能存储的数据**

`VARCHAR(M)`类型的列最多可以占用`65535`个`字节`，其中M代表最多存储的`字符`数量   。

MySQL 对一条记录占用的最大存储空间是有限制的，除了BLOB 或者TEXT 类型的列之外，其他所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节。

其实需要占用3部分存储空间：

* 真实数据
* 真实数据占用字节的长度
* `NULL`值标识，如果该列有`NOT NULL`属性则可以没有这部分存储空间

如果该`VARCHAR`类型的列没有`NOT NULL`属性，那最多只能存储`65532`个字节的数据，因为真实数据的长度可能占用2个字节，`NULL`值标识需要占用1个字节。

```text
述所言在列的值允许为NULL的情况下，gbk字符集下M的最大取值就是32766，
utf8字符集下M的最大取值就是21844，这都是在表中只有一个字段的情况下说的，
一定要记住一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节！
```

疑问：

1、行长度会计算 text 跟 blob 类型的字段吗？？？

2、如果不包含，那text 跟 blob 怎么处理？？？

不只是 _**VARCHAR\(M\)**_ 类型的列，其他的 _**TEXT**_、_**BLOB**_ 类型的列在存储数据非常多的时候也会发生`行溢出`。



## 2 InnoDB 数据页结构

InnoDB 都是以页为基本单位存放数据的。

### 2.1 数据页结构速览

![](../.gitbook/assets/image%20%28151%29.png)

![](../.gitbook/assets/image%20%28147%29.png)

![](../.gitbook/assets/image%20%28140%29.png)

### 2.2 页目录

查找记录时使用。

```text
1、将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。

2、每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该记录拥有多少条记录，
也就是该组内共有几条记录。

3、将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，
这个地方就是所谓的Page Directory，也就是页目录（此时应该返回头看看页面各个部分的图）。
页面目录中的这些地址偏移量被称为槽（英文名：Slot），所以这个页面目录就是由槽组成的。
```

![](../.gitbook/assets/image%20%28156%29.png)





设计`InnoDB`的大叔们对每个分组中的记录条数是有规定的：对于最小记录所在的分组只能有 _**1**_ 条记录，最大记录所在的分组拥有的记录条数只能在 _**1~8**_ 条之间，剩下的分组中记录的条数范围只能在是 _**4~8**_ 条之间。所以分组是按照下边的步骤进行的：

* 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。
* 之后每插入一条记录，都会从`页目录`中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的`n_owned`值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。
* 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在`页目录`中新增一个`槽`来记录这个新增分组中最大的那条记录的偏移量。

### 2.3 在数据页中查找记录

一个数据页中查找指定主键值的记录的过程分为两步：

1. 通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。
2. 通过记录的`next_record`属性遍历该槽所在的组中的各个记录。



### 2.4 Page Header （数据页的通用信息）

记录一个数据页中存储的记录的状态信息。比如当前页存储了多少记录，第一条记录的地址，页目录中有多少个槽等。

![](../.gitbook/assets/image%20%28142%29.png)



### 2.5 File Header \(文件头部\)  各种类型的页都通用

页的通用信息。比如这个页的编号，它的上一个页，下一个页是谁等等。

![](../.gitbook/assets/image%20%28155%29.png)

### 2.6 File Trailer

由`8`个字节组成，可以分成2个小部分：

```text
前4个字节代表页的校验和
后4个字节代表页面被最后修改时对应的日志序列位置（LSN）
```

## 3 B+ 树索引

各个数据页组成一个`双向链表`，而`每个数据页`中的记录会按照从小到大的顺序组成一个`单向链表`，每个数据页都会为存储在他里面的记录生成一个`页目录`，在通过主键查找某条记录的时候可以在页目录中使`用二分法`快速定位到`槽`，然后再遍历`槽对应分组中的记录`即可快速找到指定的记录。

### 3.1 没有索引的查找

1、单页

如果使用主键为搜索条件，可以利用\`页目录\`  中的槽，使用二分法快速找到指定记录；

如果以其他列为搜索条件，只能从最小记录开始一次遍历单链表中的每条记录，然后对比记录是不是符合搜索条件。 

2、多页

如果不使用索引，则需要从头到尾查找。



### 3.2 索引

再贴一遍行记录 跟页结构

![](../.gitbook/assets/image%20%28144%29.png)

![&#x9875;&#x8BB0;&#x5F55;](../.gitbook/assets/image%20%28149%29.png)

#### 3.2.1 一个简单的索引

1、一个页的主键范围 必须小于后面一个页 的范围最小主键。后面一个页 在数字上不一定是相邻的。页在物理存储上可能并不挨着

2、为页做好目录项，每个页对应一个目录项，每个目录项包含两个部分：

* 页的用户记录中最小的主键值
* 页号。

3、查找顺序：先根据页的目录项查找到具体的页，然后利用页目录中的槽，快速找到页中的记录。



#### 3.2.2 InnoDB中的索引

1、也使用页来存储 页的目录项

2、只有一个目录项 页 的查询

根据某个主键值去查找记录的步骤就可以大致拆分成下边两步：

（1）先到存储`目录项记录`的页，也就是页`30`中通过二分法快速定位到对应目录项，因为`12 < 20 < 209`，所以定位到对应的记录所在的页就是`页9`。

（2）再到存储用户记录的`页9`中根据二分法快速定位到主键值为`20`的用户记录。



3、包含多个 目录项 页的查询

（1）确定`目录项记录`页

（2）通过`目录项记录`页确定用户记录真实所在的页。

（3）在真实存储用户记录的页中定位到具体的记录。

4、多级目录项的页 形成一颗树，就是B+ 树。一般情况下，我们用到的`B+`树都不会超过4层，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页）

![](../.gitbook/assets/image%20%28158%29.png)

![](../.gitbook/assets/image%20%28148%29.png)

5、聚簇索引

具有如下两个特征的索引成为聚簇索引：

```text
1、使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：

（1）页内的记录是按照主键的大小顺序排成一个单向链表。

（2）各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。

（3）存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。

2、B+树的叶子节点存储的是完整的用户记录。

所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。
```

`聚簇索引`并不需要我们在`MySQL`语句中显式的使用`INDEX`语句去创建。`InnoDB`存储引擎会自动的为我们创建聚簇索引。另外有趣的一点是，在`InnoDB`存储引擎中，`聚簇索引`就是数据的存储方式，也就是所谓的索引即数据，数据即索引。

6、二级索引

具有如下特征：

```text
1、使用非主键列进行记录和页的排序
2、叶子节点中存储的并不是完整的用户记录，而只是 索引列和主键 这两列的值。
3、目录项记录中不再是主键+页号的搭配，而变成了c2列+页号的搭配。
```

![](../.gitbook/assets/image%20%28150%29.png)

因为叶子节点只有索引列和主键，所以有可能需要回表。

7、联合索引

可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引。

比方说我们想让`B+`树按照`c2`和`c3`列的大小进行排序，这个包含两层含义：

* 先把各个记录和页按照`c2`列进行排序。
* 在记录的`c2`列相同的情况下，采用`c3`列进行排序

![](../.gitbook/assets/image%20%28152%29.png)

千万要注意一点，以c2和c3列的大小为排序规则建立的B+树称为联合索引，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，

不同点如下：

* 建立`联合索引`只会建立如上图一样的1棵`B+`树。
* 为c2和c3列分别建立索引会分别以`c2`和`c3`列的大小为排序规则建立2棵`B+`树。

8、InnoDB 的B+树索引的注意事项

8.1 根页面始终不动

当数据少时，数据都放在根页面中，随着数据增多，进行页分裂。

8.2 **内节点中目录项记录的唯一性** 

**8.3 一个页面最少存储2条记录**

一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中只能存放一条记录。费了半天劲只能存放一条真实的用户记录**。**

\*\*\*\*

**9、MyISAM 索引与 InnoDB 索引的区别**

`MyISAM`的索引方案虽然也使用树形结构，但是却将索引和数据分开存储.



\*\*\*\*



## 4 B+ 树索引的使用

### 4.1 索引的代价

1、空间上的代价：每个索引都要建立B+树，需要占用存储空间

2、时间上的代价：每次对表进行增加、删除、修改操作时，都需要去修改各个B+ 树索引。

### 4.2 B+树索引适用的条件 

一个表中有多少索引就会建立多少棵B+ 树。

来个demo:

```text
CREATE TABLE person_info(
    id INT NOT NULL auto_increment,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
```

![](../.gitbook/assets/image%20%28141%29.png)



从图中可以看出，这个`idx_name_birthday_phone_number`索引对应的`B+`树中页面和记录的排序方式就是这样的：

* 先按照`name`列的值进行排序。
* 如果`name`列的值相同，则按照`birthday`列的值进行排序。
* 如果`birthday`列的值也相同，则按照`phone_number`的值进行排序。

#### 4.2.1 全值匹配

搜索条件中的列和索引列一致，则是全值匹配。

搜索条件中的顺序 对是否使用索引没有影响，因为查询优化器会按照可以用的索引决定先使用哪个搜索条件。

#### 4.2.2 匹配左边的列

在搜索语句中也可以不用包含全部联合索引中的列，只包含左边的就行。

这要从 索引树结构的角度 解释。 

#### 4.2.3 匹配列前缀

对于字符串类型的索引列来说，只匹配它的前缀也是可以快速定位记录的。但是只给后缀或者中间的某几个字符串，是无法定位的。



#### 4.2.4 匹配范围值

所有记录都是按照索引列的值从小到大的顺序排好序的，所以这极大的方便我们查找索引列的值在某个范围内的记录。

不过在使用联合进行范围查找的时候需要注意，如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到`B+`树索引

#### 4.2.5 精确匹配某一列并范围匹配另外一列

对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找，

#### 4.2.6 用于排序

在`MySQL`中，把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名：`filesort`），跟`文件`这个词儿一沾边儿，就显得这些排序操作非常慢了。

但是如果`ORDER BY`子句里使用到了我们的索引列，就有可能省去在内存或文件中排序的步骤。

#### 4.2.7  使用联合索引进行排序注意事项

对于`联合索引`有个问题需要注意，`ORDER BY`的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出`ORDER BY phone_number, birthday, name`的顺序，那也是用不了`B+`树索引。（原来的联合索引顺序是 name, birtyday, phone\_number）。



#### 4.2.8 不可以使用索引的几种情况

1、**ASC、DESC混用**

对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是`ASC`规则排序，要么都是`DESC`规则排序。

2、**排序列包含非同一个索引的列**

用来排序的多个列不是一个索引里的，这种情况也不能使用索引进行排序

**3、排序列使用了复杂的表达式**

要想使用索引进行排序操作，必须保证索引列是以单独列的形式出现，而不是修饰过的形式

#### 4.2.9 用于分组

和使用`B+`树索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组。

### 4.3 回表的代价

#### 4.3.1、二级索引 顺序io 与 随机io

索引的记录是顺序的，把这些连着的记录从磁盘中读出来，这种读取方式我们也可以称为`顺序I/O`。根据二级索引获取到的记录的`id`字段的值可能并不相连，而在聚簇索引中记录是根据`id`（也就是主键）的顺序排列的，所以根据这些并不连续的`id`值到聚簇索引中访问完整的用户记录可能分布在不同的数据页中，这样读取完整的用户记录可能要访问更多的数据页，这种读取方式我们也可以称为`随机I/O`。一般情况下，顺序I/O比随机I/O的性能高很多。



#### 4.3.2、有些时候使用 ”二级索引 + 回表“ 还不如直接全表扫描快。。。。。

主要取决于回表的次数。

```text
什么时候采用全表扫描的方式，什么时候使用采用二级索引 + 回表的方式去执行查询呢？
这个就是传说中的查询优化器做的工作，
查询优化器会事先对表中的记录计算一些统计数据，
然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，
需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用二级索引 + 回表的方式。
```



#### 4.3.3 覆盖索引

为了彻底告别`回表`操作带来的性能损耗，我们建议：最好在查询列表里只包含索引列.

如果覆盖索引也覆盖不了所有要查询的列怎么办？

`可以先根据能覆盖索引的列查询，查出记录以及id 之后，根据id 查 没有覆盖的列。`

### 4.4 如何挑选索引

#### 4.4.1 只为用于搜索、排序或分组的列创建索引



#### 4.4.2 考虑列的基数

`列的基数`指的是某一列中不重复数据的个数。 这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。



```text
比方说某个列包含值2, 5, 8, 2, 5, 8, 2, 5, 8，虽然有9条记录，但该列的基数却是3。
也就是说，在记录行数一定的情况下，列的基数越大，该列中的值越分散，
列的基数越小，该列中的值越集中。
这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。
假设某个列的基数为1，也就是所有记录在该列中的值都一样，那为该列建立索引是没有用的，
因为所有值都一样就无法排序，无法进行快速查找了～ 
而且如果某个建立了二级索引的列的重复值特别多，那么使用这个二级索引查出的记录还可能要做回表操作，
这样性能损耗就更大了。
```

所以结论就是：最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。



#### 4.4.3 索引列的类型尽量小

* 数据类型越小，在查询时进行的比较操作越快（这是CPU层次的东东）
* 数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘`I/O`带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。

#### 4.4.4 索引字符串值的前缀

假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的`B+`树中有这么两个问题：

* `B+`树索引中的记录需要把该列的完整字符串存储起来，而且字符串越长，在索引中占用的存储空间越大。
* 如果`B+`树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。

只对字符串的前几个字符进行索引也就是说在二级索引的记录中`只保留字符串前几个字符`。这样在查找记录时虽然`不能`精确的定位到记录的位置，但是`能定位到相应前缀所在的位置`，然后根据前缀相同的记录的主键值回表查询完整的字符串值，再对比就好了。这样只在`B+`树中存储字符串的前几个字符的编码，既节约空间，又减少了字符串的比较时间，还大概能解决排序的问题。



#### 4.4.5 索引列前缀对排序的影响

因为二级索引中不包含完整的列信息，所以无法对前十个字符（假设前缀长度取10个字符）相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式无法支持使用索引排序，只好乖乖的用文件排序喽。  


#### 4.4.6 让索引列在比较表达式中单独出现

1. `WHERE my_col * 2 < 4  不能使用索引`
2. `WHERE my_col < 4/2   可以使用索引`

如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。

#### 4.4.7 主键插入顺序

如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽大忽小的话，这就比较麻烦了。忽大忽小，会导致页面分裂和记录移位，意味着：性能损耗！

建议：让主键具有`AUTO_INCREMENT`，让存储引擎自己为表生成主键，而不是我们手动插入。

#### 4.4.8 冗余和重复索引

维护冗余索引只会增加维护的成本，并不会对搜索有什么好处。



## 5 MySQL的数据目录

### 5.1 数据库和文件系统的关系

表数据需要存储在文件系统中。读取、写入数据都要跟文件系统打交道。

### 5.2 MySQL数据目录

1、数据目录是存放数据的目录，不是MySQL的安装目录。

2、查看  show variables like 'datadir'

### 5.3 数据目录的结构

#### 5.3.1 数据库在文件系统中的表示

每个数据库都对应数据目录下的一个子目录，或者说一个文件夹。

创建一个数据库时，MySQL会做两件事：

* 在数据目录下创建一个子目录
* 在该与数据库同名的子目录下创建一个名为 db.opt 的文件，这个文件中包含了该数据库的各种属性。

#### 5.3.2 表在文件系统中的标识

表的信息分为两种：

* 表结构的定义：表里面有多少列，约束条件，索引，字符集，比较规则等。在数据库子目录中，有一个  表名.frm  的二进制结构。
* 表中的数据：

#### 5.3.3 InnoDB是如何存储表数据的

InnoDB 为了更好地管理页，提出了表空间 的概念，这个表空间 是一个逻辑概念，它可以对应文件系统上一个或多个真实文件。每个表空间可以被划分为很多个页。表空间分类如下：

1 系统表空间

系统表空间可以对应文件系统上一个或多个实际的文件。在MySQL 中系统表空间只有一份。从MySQL5.5.7到MySQL5.6.6之间的各个版本中，我们表中的数据都会被默认存储到这个 _**系统表空间**_。

2 独立表空间

在MySQL5.6.6以及之后的版本中，`InnoDB`并不会默认的把各个表的数据存储到系统表空间中，而是为每一个表建立一个独立表空间，也就是说我们创建了多少个表，就有多少个独立表空间。

每个表有一个独立表空间，名字为    表名.ibd

3 其他类型的表空间

新增的一些，暂时不整理。

#### 5.3.4 视图在文件系统中的表示

1、视图只是一个虚拟的表，不需要存储真实的数据，只需要把它的结构存储起来就行了。和表一样，描述视图结构的文件也会存储在数据库对应的子目录下。

#### 5.3.5 其他的文件

除了上边说的这些用户自己存储的数据以外，`数据目录`下还包括为了更好运行程序的一些额外文件，主要包括这几种类型的文件：

服务器进程文件。

服务器日志文件。

默认/自动生成的SSL和RSA证书和密钥文件。



### 5.4 文件系统对数据库的影响

1、数据库名称和表名称不得超过文件系统所允许的最大长度。

2、特殊字符的问题

3、文件长度受文件系统最大长度限制

### 5.5 MySQL系统数据库简介

MySQL的几个系统数据库包含了MySQL服务器运行过程中所需的一些信息以及一些运行状态信息.

```text
1 mysql

这个数据库贼核心，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，
一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。

2 information_schema

这个数据库保存着MySQL服务器维护的所有其他数据库的信息，
比如有哪些表、哪些视图、哪些触发器、哪些列、哪些索引吧啦吧啦。
这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为元数据。

3 performance_schema

这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，算是对MySQL服务器的一个性能监控。
包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等等信息。

4 sys

这个数据库主要是通过视图的形式把information_schema和performance_schema结合起来，
让程序员可以更方便的了解MySQL服务器的一些性能信息。
```

## 6 InnoDB的表空间

表空间是一个抽象的概念，可以裂解成被切分为许许多多个页的池子。

### 6.1 独立表空间结构

#### 6.1.1  区 （extent）

为了管理表空间中的页，提出了区的概念，每64个页 组成一个区（一个页16K, 一个区 正好是1M\)，每256个区被划分为一个组。

![&#x7EC4; - &#x533A; - &#x9875;](../.gitbook/assets/image%20%28161%29.png)

1、第一个组的前三个页面是固定的。分别是如下信息：

```text
1、FSP_HDR 类型： 这个类型的页面是用来登记整个表空间的一些整体属性以及本组所有的区，
也就是extent 0 ~ extent 255这256个区的属性
2、IBUF_BITMAP类型：这个类型的页面是存储本组所有的区的所有页面关于INSERT BUFFER的信息。
3、INODE类型：这个类型的页面存储了许多称为INODE的数据结构
```

2、其余各组的前两个页面是固定的。分别是如下信息：

```text
1、XDES类型：全称是extent descriptor，用来登记本组256个区的属性
2、IBUF_BITMAP类型
```

#### 6.1.2 段

虽然区是一个逻辑概念，但是一个区就是在物理位置上连续的64个页。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照`区`为单位分配，避免随机IO,甚至在表中的数据十分非常特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足填充满整个区），但是从性能角度看，可以消除很多的随机`I/O。`

叶子节点有自己独有的`区`，非叶子节点也有自己独有的`区`。存放叶子节点的区的集合就算是一个`段`（`segment`），存放非叶子节点的区的集合也算是一个`段`。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。

还有一个碎片区的概念，如果一个表中的数据比较少，开始的时候并不是直接分配两个段，而是如下操作：

```text
在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。

当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间。
```

`所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合。`

#### 6.1.3 区的分类

1、分类：

```text
1 空闲的区：现在还没有用到这个区中的任何页面。

2 有剩余空间的碎片区：表示碎片区中还有可用的页面。

3 没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面。

4 附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，
除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。
```

上述四种类型的区对应4个状态：

```text
状态名	含义
FREE	空闲的区
FREE_FRAG	有剩余空间的碎片区
FULL_FRAG	没有剩余空间的碎片区
FSEG	附属于某个段的区
```

2、XDES Entry 结构

用于记录区的一些属性。

![](../.gitbook/assets/image%20%28159%29.png)

segment id: 表示该区所在的段

List Node:  这个部分将若干个XDES Entry 串联成一个链表。

State: 区的状态

page state bitmap \(16个字节\): 这个部分共占用16个字节，也就是128个比特位。我们说一个区默认有64个页，这128个比特位被划分为64个部分，每个部分2个比特位，对应区中的一个页。

第一个比特位表示对应的页是否空闲，第二个比特位还没有用。

3、XDES Entry 链表

将FREE、FREE_FRAG 、FULL_FRAG 对应的 XDES Entry 结构单独连接为三个链表，这样插入数据时，需要对应状态的区时，可以直接从对应的链表中获取。

4、链表基节点

这个结构中包含了链表的头节点和尾结点的指针，以及这个链表中包含了多少节点的信息。

![](../.gitbook/assets/image%20%28160%29.png)

#### 6.1.4 段的结构

段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。

1、使用INODE Entry 来记录段中的属性

![](../.gitbook/assets/image%20%28163%29.png)

```text
Segment ID

就是指这个INODE Entry结构对应的段的编号（ID）。

NOT_FULL_N_USED

这个字段指的是在NOT_FULL链表中已经使用了多少个页面。

3个List Base Node

分别为段的FREE链表、NOT_FULL链表、FULL链表定义了List Base Node，
这样我们想查找某个段的某个链表的头节点和尾节点的时候，就可以直接到这个部分找到对应链表的List Base Node。so easy!

Magic Number：

这个值是用来标记这个INODE Entry是否已经被初始化了（初始化的意思就是把各个字段的值都填进去了）。如果这个数字是值的97937874，表明该INODE Entry已经初始化，否则没有被初始化。（不用纠结这个值有啥特殊含义，人家规定的）。

Fragment Array Entry

我们前边强调过无数次段是一些零散页面和一些完整的区的集合，
每个Fragment Array Entry结构都对应着一个零散的页面，这个结构一共4个字节，表示一个零散页面的页号。


```

#### 6.1.5 各类型页面的详细情况

1、FSP\_HDR 类型

它存储了表空间的一些整体属性以及第一个组内256个区的对应的`XDES Entry`结构。



2、**File Space Header部分**

这个部分是用来存储表空间的一些整体属性的

**3、XDES Entry部分**

\*\*\*\*

**4、IBUF\_BITMAP类型**

这种类型的页里边记录了一些有关`Change Buffer`的东东

**5、INODE类型**

这个结构中记录了关于这个段的相关属性。

**6。。。**

\*\*\*\*

#### 6.1.6 真实表空间对应的文件大小

开始表空间占用的空间自然是很小，因为表里边都没有数据嘛！不过别忘了这些`.ibd`文件是自扩展的，随着表中数据的增多，表空间对应的文件也逐渐增大。

### 6.2 系统表空间

系统表空间的结构和独立表空间基本类似，只不过由于整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，所以会比独立表空间多出一些记录这些信息的页面。因为这个系统表空间最牛逼，相当于是表空间之首，所以它的`表空间 ID`（Space ID）是`0`。

#### 

## 

  

