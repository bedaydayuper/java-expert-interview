# MySQL查询优化\(一\) 基础知识

## 1 基于成本的优化

### 1.1 什么是成本？

1、成本由两部分组成：

I/O 成本 ：从磁盘上加载页到内存所需要的成本。

CPU成本：读取以及检测记录是否满足对应的搜索条件、对结果进行排序等损耗。

### 1.2 单表查询的成本

```text
CREATE TABLE single_table (
    id INT NOT NULL AUTO_INCREMENT,
    key1 VARCHAR(100),
    key2 INT,
    key3 VARCHAR(100),
    key_part1 VARCHAR(100),
    key_part2 VARCHAR(100),
    key_part3 VARCHAR(100),
    common_field VARCHAR(100),
    PRIMARY KEY (id),
    KEY idx_key1 (key1),
    UNIQUE KEY idx_key2 (key2),
    KEY idx_key3 (key3),
    KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;
```

#### 1.2.1 基于成本的优化步骤

0、概述

在一条单表查询语句真正执行之前，`MySQL`的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的`执行计划`，之后才会调用存储引擎提供的接口真正的执行查询， 过程如下：

```text
1、根据搜索条件，找出所有可能使用的索引

2 计算全表扫描的代价

3 计算使用不同索引执行查询的代价

4 对比各种执行方案的代价，找出成本最低的那一个
```

1 找出所有的索引

possible key.

2 计算全表扫描的代价

代价由两部分组成：

```text
1 聚簇索引占用的页面数
2 该表中的记录数
```

MySQL 维护了一系列的统计信息。使用 SHOW TABLE STATUS LIKE 'single\_table'\G 查看。



3、计算使用不同索引执行查询的代价

\(1\) 二级索引 + 回表 计算成本依赖两部分数据：

```text
1、范围区间数量
2、需要回表的数据
```



4、比对，选择最低的一个



#### 1.2.2 基于索引统计数据的成本计算

1、index dive:

把这种通过直接访问索引对应的`B+`树来计算某个范围区间对应的索引记录条数的方式称之为`index dive`

`2、`如果我们的`IN`语句中的参数个数小于200个的话，将使用`index dive`的方式计算各个单点区间对应的记录条数，如果大于或等于200个的话，可就不能使用`index dive`了，要使用所谓的索引统计数据来进行估算。



SHOW INDEX FROM 表名  来查询索引的一些统计数据。

`Cardinality`直译过来就是`基数`的意思，表示索引列中不重复值的个数。

使用索引统计数据，这里所指的`索引统计数据`指的是这两个值：

```text
1、使用SHOW TABLE STATUS展示出的Rows值，也就是一个表中有多少条记录
2、使用SHOW INDEX语句展示出的Cardinality属性。
```



3、使用统计数据来计算单点区间对应的索引记录条数可比`index dive`的方式简单多了，但是它的致命弱点就是：不精确！

### 1.3 连接查询的成本

#### 1.3.1 Condition filtering介绍

1、连接查询 驱动表会被访问1次，被驱动表会被访问多次。所以两表连接查询成本由两部分组成：

```text
1、单次查询驱动表的成本。
2、多次查询被驱动表的成本。
```

2、驱动表的扇出值： 驱动表查询之后的结果条数。

3、在这两种情况下计算驱动表扇出值时需要靠`猜`：

```text
如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要猜满足搜索条件的记录到底有多少条。

如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。
```

把这个`猜`的过程称之为`condition filtering`

#### 1.3.2 两表连接的成本分析

```text
连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本
```

1、对于外连接

对于左（外）连接和右（外）连接查询来说，它们的驱动表是固定的，所以想要得到最优的查询方案只需要：

* 分别为驱动表和被驱动表选择成本最低的访问方法。

2、对于内连接

可是对于内连接来说，驱动表和被驱动表的位置是可以互换的，所以需要考虑两个方面的问题：

* 不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序。
* 然后分别为驱动表和被驱动表选择成本最低的访问方法。

#### 1.3.3 多表连接的成本分析

有`n`个表进行连接，`MySQL`查询优化器要每一种连接顺序的成本都计算一遍么？那可是`n!`种连接顺序呀。其实真的是要都算一遍，不过设计`MySQL`的大叔们想了很多办法减少计算非常多种连接顺序的成本的方法：

```text
1、提前结束某种顺序的成本评估：
MySQL在计算各种链接顺序的成本之前，会维护一个全局的变量，
这个变量表示当前最小的连接查询成本。如果在分析某个连接顺序的成本时，
该成本已经超过当前最小的连接查询成本，那就压根儿不对该连接顺序继续往下分析了。

2、系统变量optimizer_search_depth
optimizer_search_depth系统变量，如果连接表的个数小于该值，
那么就继续穷举分析每一种连接顺序的成本，否则只对与optimizer_search_depth值相同数量的表进行穷举分析。

3、根据某些规则压根儿就不考虑某些连接顺序
启发式规则（就是根据以往经验指定的一些规则），凡是不满足这些规则的连接顺序压根儿就不分析，
这样可以极大的减少需要分析的连接顺序的数量，但是也可能造成错失最优的执行计划。


```



### 1.4 调节成本常数

在`server`层进行连接管理、查询缓存、语法解析、查询优化等操作，在存储引擎层执行具体的数据存取操作。也就是说一条语句在`server`层中执行的成本是和它操作的表使用的存储引擎是没关系的，所以关于这些操作对应的`成本常数`就存储在了`server_cost`表中，而依赖于存储引擎的一些操作对应的`成本常数`就存储在了`engine_cost`表中。





## 2 InnoDB 统计数据是如何收集的？

### 2.1 两种不同的统计数据存储方式

1、永久性的统计数据

存放在磁盘上

2、非永久性的统计数据

存放在内存中

### 2.2 基于磁盘的永久性统计数据

#### 2.2.1 innodb\_table\_stats

存储了表的统计信息，一条记录对应一个表的统计数据。

![](../.gitbook/assets/image%20%28172%29.png)

1、n\_rows 统计项的收集

按照一定算法（并不是纯粹随机的）选取几个叶子节点页面，计算每个页面中主键值记录数量，然后计算平均一个页面中主键值的记录数量乘以全部叶子节点的数量就算是该表的`n_rows`值。

#### 2.2.2 innodb\_index\_stats

存储了关于索引的统计数据，每一条记录对应一个索引的一个统计项的统计数据。

![](../.gitbook/assets/image%20%28173%29.png)

针对`index_name`列相同的记录，`stat_name`表示针对该索引的统计项名称，`stat_value`展示的是该索引在该统计项上的值，`stat_description`指的是来描述该统计项的含义的。



#### 2.2.3 定期更新统计数据

1、在变更数据到达一定比例（比如占表大小的10%）异步执行。

2、也可以手动触发。这个过程是同步的，在表中索引多或者采样页面特别多时这个过程可能会特别慢，请不要没事儿就运行一下`ANALYZE TABLE`语句，最好在业务不是很繁忙的时候再运行。

### 2.3 基于内存的非永久性统计数据

由于非永久性的统计数据经常更新，所以导致`MySQL`查询优化器计算查询成本的时候依赖的是经常变化的统计数据，也就会生成经常变化的执行计划，这个可能让大家有些懵逼。不过最近的`MySQL`版本都不咋用这种基于内存的非永久性统计数据了，

#### 2.3.1 innodb\_stats\_method的使用

针对NULL 是否算作一个不重复值，提供了一个名为`innodb_stats_method`的系统变量，相当于在计算某个索引列不重复值的数量时如何对待`NULL`值这个锅甩给了用户，这个系统变量有三个候选值：

* `nulls_equal`：认为所有`NULL`值都是相等的。这个值也是`innodb_stats_method`的默认值。

  如果某个索引列中`NULL`值特别多的话，这种统计方式会让优化器认为某个列中平均一个值重复次数特别多，所以倾向于不使用索引进行访问。

* `nulls_unequal`：认为所有`NULL`值都是不相等的。

  如果某个索引列中`NULL`值特别多的话，这种统计方式会让优化器认为某个列中平均一个值重复次数特别少，所以倾向于使用索引进行访问。

* `nulls_ignored`：直接把`NULL`值忽略掉。





