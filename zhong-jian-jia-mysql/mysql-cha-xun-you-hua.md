# MySQL查询优化\(一\) 基础知识

## 1 基于成本的优化

### 1.1 什么是成本？

1、成本由两部分组成：

I/O 成本 ：从磁盘上加载页到内存所需要的成本。

CPU成本：读取以及检测记录是否满足对应的搜索条件、对结果进行排序等损耗。

### 1.2 单表查询的成本

```text
CREATE TABLE single_table (
    id INT NOT NULL AUTO_INCREMENT,
    key1 VARCHAR(100),
    key2 INT,
    key3 VARCHAR(100),
    key_part1 VARCHAR(100),
    key_part2 VARCHAR(100),
    key_part3 VARCHAR(100),
    common_field VARCHAR(100),
    PRIMARY KEY (id),
    KEY idx_key1 (key1),
    UNIQUE KEY idx_key2 (key2),
    KEY idx_key3 (key3),
    KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;
```

#### 1.2.1 基于成本的优化步骤

0、概述

在一条单表查询语句真正执行之前，`MySQL`的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案，这个成本最低的方案就是所谓的`执行计划`，之后才会调用存储引擎提供的接口真正的执行查询， 过程如下：

```text
1、根据搜索条件，找出所有可能使用的索引

2 计算全表扫描的代价

3 计算使用不同索引执行查询的代价

4 对比各种执行方案的代价，找出成本最低的那一个
```

1 找出所有的索引

possible key.

2 计算全表扫描的代价

代价由两部分组成：

```text
1 聚簇索引占用的页面数
2 该表中的记录数
```

MySQL 维护了一系列的统计信息。使用 SHOW TABLE STATUS LIKE 'single\_table'\G 查看。



3、计算使用不同索引执行查询的代价

\(1\) 二级索引 + 回表 计算成本依赖两部分数据：

```text
1、范围区间数量
2、需要回表的数据
```



4、比对，选择最低的一个



#### 1.2.2 基于索引统计数据的成本计算

1、index dive:

把这种通过直接访问索引对应的`B+`树来计算某个范围区间对应的索引记录条数的方式称之为`index dive`

`2、`如果我们的`IN`语句中的参数个数小于200个的话，将使用`index dive`的方式计算各个单点区间对应的记录条数，如果大于或等于200个的话，可就不能使用`index dive`了，要使用所谓的索引统计数据来进行估算。



SHOW INDEX FROM 表名  来查询索引的一些统计数据。

`Cardinality`直译过来就是`基数`的意思，表示索引列中不重复值的个数。

使用索引统计数据，这里所指的`索引统计数据`指的是这两个值：

```text
1、使用SHOW TABLE STATUS展示出的Rows值，也就是一个表中有多少条记录
2、使用SHOW INDEX语句展示出的Cardinality属性。
```



3、使用统计数据来计算单点区间对应的索引记录条数可比`index dive`的方式简单多了，但是它的致命弱点就是：不精确！

### 1.3 连接查询的成本

#### 1.3.1 Condition filtering介绍

1、连接查询 驱动表会被访问1次，被驱动表会被访问多次。所以两表连接查询成本由两部分组成：

```text
1、单次查询驱动表的成本。
2、多次查询被驱动表的成本。
```

2、驱动表的扇出值： 驱动表查询之后的结果条数。

3、在这两种情况下计算驱动表扇出值时需要靠`猜`：

```text
如果使用的是全表扫描的方式执行的单表查询，那么计算驱动表扇出时需要猜满足搜索条件的记录到底有多少条。

如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。
```

把这个`猜`的过程称之为`condition filtering`

#### 1.3.2 两表连接的成本分析

```text
连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本
```

1、对于外连接

对于左（外）连接和右（外）连接查询来说，它们的驱动表是固定的，所以想要得到最优的查询方案只需要：

* 分别为驱动表和被驱动表选择成本最低的访问方法。

2、对于内连接

可是对于内连接来说，驱动表和被驱动表的位置是可以互换的，所以需要考虑两个方面的问题：

* 不同的表作为驱动表最终的查询成本可能是不同的，也就是需要考虑最优的表连接顺序。
* 然后分别为驱动表和被驱动表选择成本最低的访问方法。

#### 1.3.3 多表连接的成本分析

有`n`个表进行连接，`MySQL`查询优化器要每一种连接顺序的成本都计算一遍么？那可是`n!`种连接顺序呀。其实真的是要都算一遍，不过设计`MySQL`的大叔们想了很多办法减少计算非常多种连接顺序的成本的方法：

```text
1、提前结束某种顺序的成本评估：
MySQL在计算各种链接顺序的成本之前，会维护一个全局的变量，
这个变量表示当前最小的连接查询成本。如果在分析某个连接顺序的成本时，
该成本已经超过当前最小的连接查询成本，那就压根儿不对该连接顺序继续往下分析了。

2、系统变量optimizer_search_depth
optimizer_search_depth系统变量，如果连接表的个数小于该值，
那么就继续穷举分析每一种连接顺序的成本，否则只对与optimizer_search_depth值相同数量的表进行穷举分析。

3、根据某些规则压根儿就不考虑某些连接顺序
启发式规则（就是根据以往经验指定的一些规则），凡是不满足这些规则的连接顺序压根儿就不分析，
这样可以极大的减少需要分析的连接顺序的数量，但是也可能造成错失最优的执行计划。


```



### 1.4 调节成本常数

在`server`层进行连接管理、查询缓存、语法解析、查询优化等操作，在存储引擎层执行具体的数据存取操作。也就是说一条语句在`server`层中执行的成本是和它操作的表使用的存储引擎是没关系的，所以关于这些操作对应的`成本常数`就存储在了`server_cost`表中，而依赖于存储引擎的一些操作对应的`成本常数`就存储在了`engine_cost`表中。





## 2 InnoDB 统计数据是如何收集的？



## 3 MySQL基于规则的优化



## 4 explain



