# MySQL 事务-redo 日志

## 1 redo 日志是什么？

记录一下都做了什么操作，然后在系统崩溃重启时按照这个日志更新。

刷新redo日志，而不是具体的数据页，好处是：

```text
占用空间小日志是顺序写入磁盘的。
```

## 2 redo 日志格式

`redo`日志本质上只是记录了一下事务对数据库做了哪些修改。

### 2.1 通用格式

![](../.gitbook/assets/image%20%28179%29.png)

其中：

```text
type: redo 日志类型space id: 表空间idpage number: 页号data: 具体内容。
```

### 2.2 简单的redo日志类型

`redo`日志中只需要记录一下在某个页面的某个偏移量处修改了几个字节的值，具体被修改的内容是啥就好了。

![](../.gitbook/assets/image%20%28178%29.png)

### 2.3 复杂一些的redo日志类型

1、把一条记录插入到一个页面时需要更改的地方非常多。

2、`redo`日志既包含`物理`层面的意思，也包含`逻辑`层面的意思，具体指：

* 物理层面看，这些日志都指明了对哪个表空间的哪个页进行了修改。
* 逻辑层面看，在系统崩溃重启时，并不能直接根据这些日志里的记载，将页面内的某个偏移量处恢复成某个数据，而是需要调用一些事先准备好的函数，执行完这些函数后才可以将页面恢复成系统崩溃前的样子。

## 3 Mini-Transaction

### 3.1 以组的形式写入redo 日志

数据、索引、二级索引 必须一起恢复，这个过程是不可分割的。必须是原子的。

### 3.2 Mini-Transaction的概念

1、什么是mini-transaction

把对底层页面中的一次原子访问的过程称之为一个`Mini-Transaction`，简称`mtr`，比如上边所说的修改一次`Max Row ID`的值算是一个`Mini-Transaction`，向某个索引对应的`B+`树中插入一条记录的过程也算是一个`Mini-Transaction`

2、一个事务可以包含若干条语句，每一条语句其实是由若干个`mtr`组成，每一个`mtr`又可以包含若干条`redo`日志，画个图表示它们的关系就是这样：

![](../.gitbook/assets/image%20%28175%29.png)

## 4 redo日志的写入过程

### 4.1 redo log block

设计`InnoDB`的大叔为了更好的进行系统崩溃恢复，他们把通过`mtr`生成的`redo`日志都放在了大小为`512字节`的`页`中. 这个页称为block.

![](../.gitbook/assets/image%20%28176%29.png)

### 4.2 redo 日志缓冲区

redo log buffer 一块连续内存空间。

每完成一组操作，一个mtr\(包含多条redo 日志\) 会写入到log buffer 中。

一个事务，可能包含多个mtr, 不同事务的mtr 日志 可能交替存储。

## 5 redo 日志刷盘时机

`mtr`运行过程中产生的一组`redo`日志在`mtr`结束时会被复制到`log buffer`中，可是这些日志总在内存里呆着也不是个办法，在一些情况下它们会被刷新到磁盘里

时机：

```text
1、log buffer 空间不足时2、事务提交时3、后台线程 每秒刷一次4、正常关闭服务器时5、做checkpoint 时6、其他的一些情况​
```

## 6 redo 日志文件组

### 6.1 redo 日志文件格式

`log buffer`本质上是一片连续的内存空间，被划分成了若干个`512`字节大小的`block`。将log buffer中的redo日志刷新到磁盘的本质就是把block的镜像写入日志文件中，所以`redo`日志文件其实也是由若干个`512`字节大小的block组成。

`redo`日志文件组中的每个文件大小都一样，格式也一样，都是由两部分组成：

* 前2048个字节，也就是前4个block是用来存储一些管理信息的。
* 从第2048字节往后是用来存储`log buffer`中的block镜像的。

### 6.2 Log Sequence Number

日志序列号。记录redo 日志的编号。

一个mtr 包含一组redo日志，那么lsn 增长时，也是按照字节数批量增长。

### 6.3 flushed\_to\_disk\_lsn

buf\_next\_to\_write 用来记录已经有哪些日志被刷新到磁盘中了。

![](../.gitbook/assets/image%20%28177%29.png)

当有新的`redo`日志写入到`log buffer`时，首先`lsn`的值会增长，但`flushed_to_disk_lsn`不变，随后随着不断有`log buffer`中的日志被刷新到磁盘上，`flushed_to_disk_lsn`的值也跟着增长。如果两者的值相同时，说明log buffer中的所有redo日志都已经刷新到磁盘中了。

### 6.4 checkpoint

```text
有一个很不幸的事实就是我们的redo日志文件组容量是有限的，我们不得不选择循环使用redo日志文件组中的文件，但是这会造成最后写的redo日志与最开始写的redo日志追尾，这时应该想到：redo日志只是为了系统崩溃后恢复脏页用的，如果对应的脏页已经刷新到了磁盘，也就是说即使现在系统崩溃，那么在重启后也用不着使用redo日志恢复该页面了，所以该redo日志也就没有存在的必要了，那么它占用的磁盘空间就可以被后续的redo日志所重用。也就是说：判断某些redo日志占用的磁盘空间是否可以覆盖的依据就是它对应的脏页是否已经刷新到磁盘里。
```

全局变量`checkpoint_lsn`来代表当前系统中可以被覆盖的`redo`日志总量是多少。

## 7 崩溃恢复

### 7.1 确定恢复的起点

根据最近发生的`checkpoint`对应的`checkpoint_lsn`值以及它在`redo`日志文件组中的偏移量`checkpoint_offset` 来确定。

### 7.2 确定恢复的终点

普通block的`log block header`部分有一个称之为`LOG_BLOCK_HDR_DATA_LEN`的属性，该属性值记录了当前block里使用了多少字节的空间。对于被填满的block来说，该值永远为`512`。如果该属性的值不为`512`，那么就是它了，它就是此次崩溃恢复中需要扫描的最后一个block。

### 7.3 怎么恢复

#### 7.3.1 正常的流程

可以按照`redo`日志的顺序依次扫描`checkpoint_lsn`之后的各条redo日志，按照日志中记载的内容将对应的页面恢复出来。

#### 7.3.2 加快恢复

1、使用哈希表

根据`redo`日志的`space ID`和`page number`属性计算出散列值，把`space ID`和`page number`相同的`redo`日志放到哈希表的同一个槽里，如果有多个`space ID`和`page number`都相同的`redo`日志，那么它们之间使用链表连接起来，按照生成的先后顺序链接起来的，之后就可以遍历哈希表，因为对同一个页面进行修改的`redo`日志都放在了一个槽里，所以可以一次性将一个页面修复好（避免了很多读取页面的随机IO），这样可以加快恢复速度。

2、跳过已经刷新到磁盘的页面

`checkpoint_lsn`之前的`redo`日志对应的脏页确定都已经刷到磁盘了，但是`checkpoint_lsn`之后的`redo`日志我们不能确定是否已经刷到磁盘，主要是因为在最近做的一次`checkpoint`后，可能后台线程又不断的从`LRU链表`和`flush链表`中将一些脏页刷出`Buffer Pool`。这些在`checkpoint_lsn`之后的`redo`日志，如果它们对应的脏页在崩溃发生时已经刷新到磁盘，那在恢复时也就没有必要根据`redo`日志的内容修改该页面了。  


