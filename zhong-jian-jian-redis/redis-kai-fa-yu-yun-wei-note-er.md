# Redis开发与运维-note（二）

## 3 小功能大用处

### 3.1 慢查询分析

1、指令的生命周期

![](../.gitbook/assets/image%20%2880%29.png)

慢查询只统计了步骤三的时间，所以没有慢查询并不代表客户端没有超时问题。

通过 slowlog-log-slower-than 来设置超过多少微秒需要记录；设置为0，则记录所有的查询。

通过 slowlog-max-len 说明慢查询日志最多存储多少条，超过之后，再插入时，会把最早的指令移除。

### 3.2  Pipeline

将一组Redis命令进行组装，通过一次RTT 传输给Redis, 再将这组Redis命令的执行结果按顺序返回给客户端，节省了多次RTT 时间。

![](../.gitbook/assets/image%20%2878%29.png)

2、原生批量命令与pipeline

可以使用pipeline 模拟出批量操作的效果，但是在使用时要注意它与原生批量命令的区别，具体包含如下几点：

* 原生批量命令是原子的，pipeline是非原子的
* 原生批量命令是一个命令对应多个key, pipeline 支持多个命令
* 原生批量命令是Redis服务端支持实现的，而pipeline 需要服务端和客户端共同实现。

3、最佳实践

pipeline 虽然好用，但是每次组装的命令个数不能没有节制，否则一次组装pipeline数据量过大，一方面增加客户端的等待时间，另一方面会造成一定的网络阻塞，可以讲一次包含大量命令的pipeline 拆分成多次较小的pipeline来完成。

### 3.3 事务与Lua

为了保证多条命令组合的原子性。

#### 3.3.1 事务

事务保证原子性。

1、执行指令

```text
multi 命令代表事务开始，exec 代表事务结束，它们之间的命令是原子顺序执行的。
如果要停止事务，可是使用discard命令。
```

Redis 的事务并不支持回滚功能，需要开发人员自己修复这类问题。同时无法实现命令之间的逻辑关系计算。



#### 3.3.2 Lua 脚本语言

1、好处：

* lua 脚本在Redis中是原子执行的
* lua 脚本可以常驻Redis内存，实现复用
* lua 脚本可以将多条命令一次性打包，减少网络开销。

2、缺点：如果开始执行，会一直占据redis 服务端线程，导致其他请求得不到处理，使用不当破坏性是难以想象的。



2、Redis 中执行lua 脚本有两种方法：eval 和 evalsha

```text
eval 脚本内容 key个数 key列表 参数列表

```

![](../.gitbook/assets/image%20%2872%29.png)

3、evalsha 

首先要将lua 脚本加载到Redis服务端，得到该脚本的sha1 校验和，evelsha 命令使用sha1 作为参数直接执行对应的lua 脚本，避免每次发送lua 脚本的开销。这样客户端不需要每次执行脚本内容，而脚本也会常驻在服务端。

（1）加载脚本

（2）执行脚本

### 3.4 Bitmaps

bitmaps 本身不是一种数据结构，实际上他就是字符串，但是它可以对字符串的位进行操作。

以位为单位的数组，数组的每个单元只存储0和1，数组的下标在bitmaps 中叫做偏移量。



## 4 客户端

### 4.1 客户端通信协议

1、Redis 基于TCP 之上，制定了RESP\(Redis serialization protocol\) ，高效，既能被机器解析，又能被人类识别。

### 4.2 java 客户端-jedis

1、

![](../.gitbook/assets/image%20%2875%29.png)

连接池可以复用连接，并且可以限制jedis 对象的个数，不至于过多，造成连接泄漏。

### 4.3 客户端管理



### 4.4 客户端常见异常



### 4.5 客户端案例分析





