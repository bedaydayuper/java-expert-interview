# Redis开发与运维-note（二）

## 3 小功能大用处

### 3.1 慢查询分析

1、指令的生命周期

![](../.gitbook/assets/image%20%2880%29.png)

慢查询只统计了步骤三的时间，所以没有慢查询并不代表客户端没有超时问题。

通过 slowlog-log-slower-than 来设置超过多少微秒需要记录；设置为0，则记录所有的查询。

通过 slowlog-max-len 说明慢查询日志最多存储多少条，超过之后，再插入时，会把最早的指令移除。

### 3.2  Pipeline

将一组Redis命令进行组装，通过一次RTT 传输给Redis, 再将这组Redis命令的执行结果按顺序返回给客户端，节省了多次RTT 时间。

![](../.gitbook/assets/image%20%2878%29.png)

2、原生批量命令与pipeline

可以使用pipeline 模拟出批量操作的效果，但是在使用时要注意它与原生批量命令的区别，具体包含如下几点：

* 原生批量命令是原子的，pipeline是非原子的
* 原生批量命令是一个命令对应多个key, pipeline 支持多个命令
* 原生批量命令是Redis服务端支持实现的，而pipeline 需要服务端和客户端共同实现。

3、最佳实践

pipeline 虽然好用，但是每次组装的命令个数不能没有节制，否则一次组装pipeline数据量过大，一方面增加客户端的等待时间，另一方面会造成一定的网络阻塞，可以讲一次包含大量命令的pipeline 拆分成多次较小的pipeline来完成。

### 3.3 事务与Lua

为了保证多条命令组合的原子性。

#### 3.3.1 事务

事务保证原子性。

1、执行指令

```text
multi 命令代表事务开始，exec 代表事务结束，它们之间的命令是原子顺序执行的。
如果要停止事务，可是使用discard命令。
```

Redis 的事务并不支持回滚功能，需要开发人员自己修复这类问题。同时无法实现命令之间的逻辑关系计算。



#### 3.3.2 Lua 脚本语言

1、好处：

* lua 脚本在Redis中是原子执行的
* lua 脚本可以常驻Redis内存，实现复用
* lua 脚本可以将多条命令一次性打包，减少网络开销。

2、缺点：如果开始执行，会一直占据redis 服务端线程，导致其他请求得不到处理，使用不当破坏性是难以想象的。



2、Redis 中执行lua 脚本有两种方法：eval 和 evalsha

```text
eval 脚本内容 key个数 key列表 参数列表

```

![](../.gitbook/assets/image%20%2872%29.png)

3、evalsha 

首先要将lua 脚本加载到Redis服务端，得到该脚本的sha1 校验和，evelsha 命令使用sha1 作为参数直接执行对应的lua 脚本，避免每次发送lua 脚本的开销。这样客户端不需要每次执行脚本内容，而脚本也会常驻在服务端。

（1）加载脚本

（2）执行脚本

### 3.4 Bitmaps

bitmaps 本身不是一种数据结构，实际上他就是字符串，但是它可以对字符串的位进行操作。

以位为单位的数组，数组的每个单元只存储0和1，数组的下标在bitmaps 中叫做偏移量。



## 4 客户端

### 4.1 客户端通信协议

1、Redis 基于TCP 之上，制定了RESP\(Redis serialization protocol\) ，高效，既能被机器解析，又能被人类识别。

### 4.2 java 客户端-jedis

1、

![](../.gitbook/assets/image%20%2875%29.png)

连接池可以复用连接，并且可以限制jedis 对象的个数，不至于过多，造成连接泄漏。

### 4.3 客户端常见异常

1、无法从连接池获取到连接

为什么？

```text
1、高并发下连接池设置过小，出现供不应求
2、客户端没有正确使用连接池，比如没有释放
3、客户端存在慢查询，这些慢查询导致持有的jedis 对象归还速度慢
4、服务端：服务端由于一些原因造成了客户端命令执行过程的阻塞
```

2、客户端读写超时

```text
1、读写超时时间设置过短
2、命令本身比较慢
3、客户端与服务端网络不正常
4、Redis 自身发生阻塞
```

3、客户端连接超时

```text
1、连接超时设置的过短
2、Redis发生阻塞，造成tcp-backlog 已满，造成新的连接失败
3、客户端与服务端网络不正常
```

4、客户端缓冲区异常

```text
1、输出缓冲区满
2、长时间闲置连接被服务端主动断开
3、不正常并发读写

```

5、Lua 脚本正在执行

6、Redis 正在加载持久化文件



7、Redis 使用的内存超过maxmemory 配置

8、客户端连接数过大

```text
1、客户端：由于应用方对于Redis客户端使用不当造成的
2、服务端：
```

## 5 持久化

### 5.1 RDB

rdb 持久化是把当前进程数据生成快照保存到硬盘的过程。

1、触发机制

手动触发 分为save 和 bgsave

> save: 阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。

> bgsave：Redis 进程执行fork 操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。对save 阻塞问题做了优化。

除了执行命令手动触发外，Redis内部还存在自动触发RDB的持久化机制：



2、bgsave 运作流程

![](../.gitbook/assets/image%20%2883%29.png)

3、优缺点

优点：

适用于备份，全量复制等场景。加载RDB 恢复数据远远快于AOF 的方式。

缺点：  
没办法做到实时持久化/秒级持久化。因为bgsave 每次运行都要执行fork操作创建子进程，属于重量级操作，频繁操作成本过高。



### 5.2 AOF（append only file）

以独立日志的方式记录每次写命令，重启时再执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性。

1、开启AOF 需要设置appendonly yes, 默认不开启。

2、工作流程：

命令写入（append）  
文件同步（sync）  
文件重写（rewrite）  
重启加载（load）



![](../.gitbook/assets/image%20%2882%29.png)

> （1）所有的写入命令会追加到aof\_buf\(缓冲区\)中
>
> （2）AOF 缓冲区根据对应的策略向硬盘做同步操作
>
> （3）随着AOF 文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的
>
> （4）当Redis服务器重启时，可以加载AOF文件进行数据恢复。

3、同步间隔：

always: 每次写入都要同步AOF文件  
no: 由操作系统控制，但是由于操作系统每次同步AOF文件的周期不可用，而会加大每次同步硬盘的数据量，虽然提升了性能，但是数据安全性无法保证。  
everysec: 1s 同步一次。

4、重写机制：  
重写之后，AOF文件会变小，因为：  


```text
1。进程内已经超时的数据不再写入文件
2、旧的AOF文件包含无效命令，新的AOF文件只保留最终数据的写入命令
3、多条写命令合并为一个
4.
```

5、触发

手动触发：bgrewriteaof

自动触发：auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage 参数确定自动触发机制。

![](../.gitbook/assets/image%20%2881%29.png)

6、重启加载  


![](../.gitbook/assets/image%20%2884%29.png)

```

```



