# Redis开发与运维-note\(三\)

## 8 理解内存

### 8.1 内存消耗

1、内存消耗分为进程自身消耗和子进程消耗

![](../.gitbook/assets/image%20%2888%29.png)

2、对象内存：

```text
redis 内存占用最大的一块。
```

3、缓冲内存

主要包括：客户端缓冲、复制积压缓冲区、AOF缓冲区。

客户端缓冲：是指所有接入到Redis服务器TCP连接的输入输出缓冲。

复制积压缓冲区：该缓冲区用来实现部分复制功能

AOF缓冲区：用于在Redis重写期间保存最近写入的命令。

4、内存碎片：

内存分配器为了更好地管理和重复利用内存，分配内存策略一般采用固定范围的内存块进行分配。一般分配器都会有内存碎片。

内存碎片的解决办法：

（1）数据对齐

（2）安全重启：重启节点可以做到内存碎片重新整理。

5、子进程内存消耗

子进程内存消耗主要是指执行AOF/RDB重写时Redis创建的子进程内存消耗。



### 8.2 内存管理

Redis主要通过控制内存上限和回收策略实现内存管理。

#### 8.2.1 设置内存上限

只能限制实际使用的内存量，不包含内存碎片。



#### 8.2.2 回收

1、删除过期键对象

惰性删除

定时任务删除

2、内存溢出控制策略

当所用内存达到maxmemory 上限时，会触发相应的溢出控制策略。



### 8.3 内存优化

#### 8.3.1 redisObject 对象

![](../.gitbook/assets/image%20%2889%29.png)

type： 对外的5种类型

encoding：内部编码类型

lru：记录对象最后一次被访问的时间

refcount: 记录当前对象被引用的次数，当refcount=0时，被回收。

ptr：与对象的数据内容相关，如果是整数，直接存储数据；否则表示指向数据的指针。

#### 8.3.2 缩减键值对象

降低redis 内存使用最直接的方式就是缩减键和值的长度。

key 长度：在完整描述业务情况下，键值越短越好。

value 长度：可以采用压缩的方式存储。

#### 8.3.3 共享对象池

共享内存池是指Redis内部维护\[0-9999\] 的整数对象池，用于节约内存。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。

为什么只有整数对象池？

> 首先整数对象池复用的几率最大，其次对象共享的一个关键操作就是判断相等性，Redis 之所以只有整数对象池，是因为整数比较算法为o\(1\),  只保留一万个整数为了防止对象池浪费。其他类型的比对，时间复杂度高。

#### 8.3.4 字符串优化

Redis 中值对象除了整数之外，都是使用的字符串存储。

1、字符串结构：

![](../.gitbook/assets/image%20%2890%29.png)

> O\(1\) 时间复杂度获取：字符串长度、已用长度、未用长度；
>
> 可用于保存字节数组，支持安全的二进制数据存储
>
> 内部实现空间预分配机制，降低内存再分配次数
>
> 惰性删除：字符串缩减后的空间不释放，作为预分配空间保留。

2、预分配机制

字符串之所以采用预分配的方式是防止修改操作需要不断重分配内存和字节数据拷贝。但同样也会造成内存的浪费。

字符串预分配每次并不都是翻倍扩容。

3、字符串重构

指不一定把每份数据作为字符串整体存储。同时，可以使用使用hmget/hmset 命令支持字段的部分读取修改，而不用每次整体存取。

#### 8.3.5 编码优化

通过不同的编码实现效率和空间的平衡。

#### 8.3.6 控制键的数量

比如 通过hash 和 ziplist 来减少key 的数量。就是使用hash 中的field 来减少key 的数量。



## 9 哨兵

### 9.1 基本原理

1、主从复制的问题

主负责写入，从节点分担主节点的读压力，并且在主节点挂掉之后，从节点晋升为主节点。

问题：

* 一旦主节点出现故障，需要手动将一个从节点晋升为主节点
* 主节点的写能力收到单机的限制
* 主节点的存储能力收到单机的限制

2、Redis sentinel 的高可用

当主节点出现故障时，Redis sentinel 能自动完成故障发现和故障转移，并通知应用方，从而实现真正的高可用。

Redis sentinel 是一个分布式架构，其中包含若干个sentinel节点和Redis数据节点，每个sentinel 节点会对数据节点和其余sentinel 节点进行监控，当它发现节点不可达时，会对节点做下线标识。如果被标识的是主节点，它还会和其他sentinel节点进行协商，当大多数sentinel节点都认为主节点不可达时，它们会选举出一个sentinel节点来完成自动故障转移的工作，同时会将这个变化实时通知给Redis应用方。



![](../.gitbook/assets/image%20%2892%29.png)

Redis sentinel 的作用：

* 监控
* 通知
* 主节点故障转移
* 配置提供者：客户端初始化的时候连接的是sentinel 节点集合。



### 9.2 实现原理

#### 9.2.1 三个定时监控任务

（1）每个10秒，每个sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构

![](../.gitbook/assets/image%20%2895%29.png)

（2）每隔2秒，每个sentinel节点会向Redis数据节点的_sentinel_:hello 频道上发送该sentinel 节点对于主节点的判断以及当前sentinel节点的信息，同时每个sentinel节点也会订阅该频道，来了解其他sentinel节点以及它们对主节点的判断。这个定时任务可以完成以下两个工作：

* 发现新的sentinel节点
* sentinel节点之间交换主节点的状态

![](../.gitbook/assets/image%20%2896%29.png)

（3）每隔1秒，每个sentinel节点会向主节点、从节点、其余sentinel节点发送一条ping 命令，进行一次心跳检测，来确认当前节点是否可达。

![](../.gitbook/assets/image%20%2893%29.png)

#### 9.2.2 主观下线和客观下线

主观下线：

sentinel 节点向其他节点发送心跳检测，如果其他节点在规定时间内没有返回，则sentinel节点就会对没有返回的节点做失败判定，这个行为叫做主观下线。主观下线是当前sentinel节点的一家之言，有误判的可能。

客观下线：

当sentinel主观下线的节点是主节点时，该sentinel 节点会向其他sentinel节点询问对主节点的判断，如果超过quorum个数，sentinel节点认为主节点确实有问题，这是该sentinel节点会做出客观下线的决定。

![](../.gitbook/assets/image%20%2894%29.png)



#### 9.2.3 领导者sentinel 节点选举

选出一个领导者sentinel节点，进行故障转移的工作。Redis采用raft算法实现领导者选举。

#### 9.2.4 故障转移

步骤：

* 在从节点中选一个作为新的主节点
* sentinel领导者节点会对第一步选出来的从节点执行slaveof no one 让其成为主节点
* sentinel领导者 向其他剩余的从节点发送命令，让他们成为新主节点的从节点
* sentinel节点集合会将原来的主节点更新为从节点，并保持对其关注，当其恢复后命令它去复制新的主节点。



![](../.gitbook/assets/image%20%2891%29.png)

## 10 集群

### 10.1 数据分布

1、数据分布原理：把数据集划分到多个节点上，每个节点负责整体数据的一个子集。

![](../.gitbook/assets/image%20%2899%29.png)

常见的分布方法：节点取余、一致性哈希、虚拟槽分区。

2、Redis 采用虚拟槽分区方法。

```text
虚拟槽分区巧妙地使用了哈希空间，使用分散度良好的哈希函数，把所有数据映射到一个固定范围的整数集合中。
整数定义为槽（slot）。这个范围一般远远大于节点数。
目的是为了方便数据拆分和集群扩展。每个节点负责一定数量的槽。

```

![](../.gitbook/assets/image%20%28100%29.png)

Redis虚拟槽分区的特点：

* 解耦数据和节点之间的关系，简化了节点扩容和收缩难度
* 节点自身维护槽的映射关系，不需要客户端维护
* 支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景。

3、集群功能限制

1. key 批量操作支持有限：目前只支持具有相同slot值的key 执行批量操作。
2. key 事务操作支持有限。只支持多key 在同一节点上的事务操作
3. key 作为数据分区的最小粒度，不能将一个大的键值对象映射到不同的节点
4. 不支持多数据库空间
5. 复制结构只支持一层，从节点只能复制到主节点，不支持嵌套树状复制结构。

疑问？？？

这些限制在开发时如何解决呢？？？？？



### 10.2 搭建集群

1、步骤：

* 准备节点
* 节点握手：通过gossip协议彼此通信，达到感知对方的过程。
* 分配槽：Redis集群会把所有的数据映射到16384个槽中。每个key 会映射为一个固定的槽，只有当节点分配了槽，才能响应和这些槽关联的键命令。被分配了槽的都是主节点，主节点还会有从节点，从节点复制主节点的槽信息和相关数据。



### 10.3 节点通信

1、元数据：节点负责哪些数据，是否出现故障等状态信息。

2、利用gossip 协议进行通信。过程如下：

* 每个节点都会单独开启一个TCP通道，用于节点之间的通信
* 每个节点在固定周期内通过特定规则选择几个节点发送ping
* 接收到ping消息的节点用pong 消息作为响应。

3、节点选择

频繁信息交换，势必加重带宽和计算的负担，所以选择一部分进行信息交换。

![](../.gitbook/assets/image%20%28102%29.png)



### 10.4 集群伸缩

1、集群伸缩=槽和数据在节点之间的移动

2、集群扩容的步骤：

* 准备新节点
* 加入集群
* 迁移槽和数据

3、收缩集群

![](../.gitbook/assets/image%20%28108%29.png)

### 10.5 请求路由

1、moved 重定向

![](../.gitbook/assets/image%20%28103%29.png)

2、键命令执行步骤

* 计算槽：哈希，然后取模。

  * 如果键内容包含{} 大括号字符，则计算槽的有效部分是括号内的内容，否则采用键的全内容计算槽。集群模式下mget 等命令优化批量调用时，键列表必须具有相同的slot, 否则会保存。

![](../.gitbook/assets/image%20%28106%29.png)

pipeline 同样受益于hash\_tag, 由于pipeline 只能向一个节点批量发送执行命令，而相同slot 必然会对应到唯一的节点，降低了集群使用pipeline 的门槛。

* 槽节点查找

每个节点中都包含了槽跟节点的映射关系。

![](../.gitbook/assets/image%20%28104%29.png)

* a

3、ASK 重定向

![](../.gitbook/assets/image%20%2898%29.png)

![](../.gitbook/assets/image%20%28105%29.png)

ASK 与moved 虽然都是对客户端的重定向控制，但是有本质的区别。ASK 重定向说明集群正在进行slot 数据迁移，客户端无法知道什么时候迁移完成，因此只是临时性的重定向。但是moved说明键对应的槽已经明确指定到新节点。



### 10.6 故障转移

当集群内少量节点出现故障时通过自动故障转移保证集群可以正常对外提供服务。

1、故障发现

分主观下线（单个节点任务不可用） 和 客观下线（多个节点都任务不可用）

2、故障恢复

![](../.gitbook/assets/image%20%28107%29.png)



## 11 缓存设计

### 11.1 缓存的收益和成本



### 11.2 缓存更新策略



### 11.3 缓存粒度控制



### 11.4 穿透优化



### 11.5 无底洞优化



### 11.6 雪崩优化



### 11.7 热点key 重建优化



## 12 开发运维的坑

