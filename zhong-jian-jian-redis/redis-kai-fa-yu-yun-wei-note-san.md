# Redis开发与运维-note\(三\)

## 8 理解内存

### 8.1 内存消耗

1、内存消耗分为进程自身消耗和子进程消耗

![](../.gitbook/assets/image%20%2888%29.png)

2、对象内存：

```text
redis 内存占用最大的一块。
```

3、缓冲内存

主要包括：客户端缓冲、复制积压缓冲区、AOF缓冲区。

客户端缓冲：是指所有接入到Redis服务器TCP连接的输入输出缓冲。

复制积压缓冲区：该缓冲区用来实现部分复制功能

AOF缓冲区：用于在Redis重写期间保存最近写入的命令。

4、内存碎片：

内存分配器为了更好地管理和重复利用内存，分配内存策略一般采用固定范围的内存块进行分配。一般分配器都会有内存碎片。

内存碎片的解决办法：

（1）数据对齐

（2）安全重启：重启节点可以做到内存碎片重新整理。

5、子进程内存消耗

子进程内存消耗主要是指执行AOF/RDB重写时Redis创建的子进程内存消耗。



### 8.2 内存管理

Redis主要通过控制内存上限和回收策略实现内存管理。

#### 8.2.1 设置内存上限

只能限制实际使用的内存量，不包含内存碎片。



#### 8.2.2 回收

1、删除过期键对象

惰性删除

定时任务删除

2、内存溢出控制策略

当所用内存达到maxmemory 上限时，会触发相应的溢出控制策略。



### 8.3 内存优化

#### 8.3.1 redisObject 对象

![](../.gitbook/assets/image%20%2889%29.png)

type： 对外的5种类型

encoding：内部编码类型

lru：记录对象最后一次被访问的时间

refcount: 记录当前对象被引用的次数，当refcount=0时，被回收。

ptr：与对象的数据内容相关，如果是整数，直接存储数据；否则表示指向数据的指针。

#### 8.3.2 缩减键值对象

降低redis 内存使用最直接的方式就是缩减键和值的长度。

key 长度：在完整描述业务情况下，键值越短越好。

value 长度：可以采用压缩的方式存储。

#### 8.3.3 共享对象池

共享内存池是指Redis内部维护\[0-9999\] 的整数对象池，用于节约内存。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。

为什么只有整数对象池？

> 首先整数对象池复用的几率最大，其次对象共享的一个关键操作就是判断相等性，Redis 之所以只有整数对象池，是因为整数比较算法为o\(1\),  只保留一万个整数为了防止对象池浪费。其他类型的比对，时间复杂度高。

#### 8.3.4 字符串优化

Redis 中值对象除了整数之外，都是使用的字符串存储。

1、字符串结构：

![](../.gitbook/assets/image%20%2890%29.png)

> O\(1\) 时间复杂度获取：字符串长度、已用长度、未用长度；
>
> 可用于保存字节数组，支持安全的二进制数据存储
>
> 内部实现空间预分配机制，降低内存再分配次数
>
> 惰性删除：字符串缩减后的空间不释放，作为预分配空间保留。

2、预分配机制

字符串之所以采用预分配的方式是防止修改操作需要不断重分配内存和字节数据拷贝。但同样也会造成内存的浪费。

字符串预分配每次并不都是翻倍扩容。

3、字符串重构

指不一定把每份数据作为字符串整体存储。同时，可以使用使用hmget/hmset 命令支持字段的部分读取修改，而不用每次整体存取。

#### 8.3.5 编码优化

通过不同的编码实现效率和空间的平衡。

#### 8.3.6 控制键的数量

比如 通过hash 和 ziplist 来减少key 的数量。就是使用hash 中的field 来减少key 的数量。



## 9 哨兵

### 9.1 基本原理

1、主从复制的问题

主负责写入，从节点分担主节点的读压力，并且在主节点挂掉之后，从节点晋升为主节点。

问题：

* 一旦主节点出现故障，需要手动将一个从节点晋升为主节点
* 主节点的写能力收到单机的限制
* 主节点的存储能力收到单机的限制

2、Redis sentinel 的高可用

当主节点出现故障时，Redis sentinel 能自动完成故障发现和故障转移，并通知应用方，从而实现真正的高可用。

Redis sentinel 是一个分布式架构，其中包含若干个sentinel节点和Redis数据节点，每个sentinel 节点会对数据节点和其余sentinel 节点进行监控，当它发现节点不可达时，会对节点做下线标识。如果被标识的是主节点，它还会和其他sentinel节点进行协商，当大多数sentinel节点都认为主节点不可达时，它们会选举出一个sentinel节点来完成自动故障转移的工作，同时会将这个变化实时通知给Redis应用方。



![](../.gitbook/assets/image%20%2892%29.png)

Redis sentinel 的作用：

* 监控
* 通知
* 主节点故障转移
* 配置提供者：客户端初始化的时候连接的是sentinel 节点集合。



### 9.2 实现原理

#### 9.2.1 三个定时监控任务

（1）每个10秒，每个sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构

![](../.gitbook/assets/image%20%2895%29.png)

（2）每隔2秒，每个sentinel节点会向Redis数据节点的_sentinel_:hello 频道上发送该sentinel 节点对于主节点的判断以及当前sentinel节点的信息，同时每个sentinel节点也会订阅该频道，来了解其他sentinel节点以及它们对主节点的判断。这个定时任务可以完成以下两个工作：

* 发现新的sentinel节点
* sentinel节点之间交换主节点的状态

![](../.gitbook/assets/image%20%2896%29.png)

（3）每隔1秒，每个sentinel节点会向主节点、从节点、其余sentinel节点发送一条ping 命令，进行一次心跳检测，来确认当前节点是否可达。

![](../.gitbook/assets/image%20%2893%29.png)

#### 9.2.2 主观下线和客观下线

主观下线：

sentinel 节点向其他节点发送心跳检测，如果其他节点在规定时间内没有返回，则sentinel节点就会对没有返回的节点做失败判定，这个行为叫做主观下线。主观下线是当前sentinel节点的一家之言，有误判的可能。

客观下线：

当sentinel主观下线的节点是主节点时，该sentinel 节点会向其他sentinel节点询问对主节点的判断，如果超过quorum个数，sentinel节点认为主节点确实有问题，这是该sentinel节点会做出客观下线的决定。

![](../.gitbook/assets/image%20%2894%29.png)



#### 9.2.3 领导者sentinel 节点选举

选出一个领导者sentinel节点，进行故障转移的工作。Redis采用raft算法实现领导者选举。

#### 9.2.4 故障转移

步骤：

* 在从节点中选一个作为新的主节点
* sentinel领导者节点会对第一步选出来的从节点执行slaveof no one 让其成为主节点
* sentinel领导者 向其他剩余的从节点发送命令，让他们成为新主节点的从节点
* sentinel节点集合会将原来的主节点更新为从节点，并保持对其关注，当其恢复后命令它去复制新的主节点。



![](../.gitbook/assets/image%20%2891%29.png)

## 10 集群

### 10.1 数据分布

1、数据分布原理：把数据集划分到多个节点上，每个节点负责整体数据的一个子集。

![](../.gitbook/assets/image%20%2899%29.png)

常见的分布方法：节点取余、一致性哈希、虚拟槽分区。

2、Redis 采用虚拟槽分区方法。

```text
虚拟槽分区巧妙地使用了哈希空间，使用分散度良好的哈希函数，把所有数据映射到一个固定范围的整数集合中。
整数定义为槽（slot）。这个范围一般远远大于节点数。
目的是为了方便数据拆分和集群扩展。每个节点负责一定数量的槽。

```

![](../.gitbook/assets/image%20%28100%29.png)

Redis虚拟槽分区的特点：

* 解耦数据和节点之间的关系，简化了节点扩容和收缩难度
* 节点自身维护槽的映射关系，不需要客户端维护
* 支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景。

3、集群功能限制

1. key 批量操作支持有限：目前只支持具有相同slot值的key 执行批量操作。
2. key 事务操作支持有限。只支持多key 在同一节点上的事务操作
3. key 作为数据分区的最小粒度，不能将一个大的键值对象映射到不同的节点
4. 不支持多数据库空间
5. 复制结构只支持一层，从节点只能复制到主节点，不支持嵌套树状复制结构。

疑问？？？

这些限制在开发时如何解决呢？？？？？



### 10.2 搭建集群

1、步骤：

* 准备节点
* 节点握手：通过gossip协议彼此通信，达到感知对方的过程。
* 分配槽：Redis集群会把所有的数据映射到16384个槽中。每个key 会映射为一个固定的槽，只有当节点分配了槽，才能响应和这些槽关联的键命令。被分配了槽的都是主节点，主节点还会有从节点，从节点复制主节点的槽信息和相关数据。



### 10.3 节点通信

1、元数据：节点负责哪些数据，是否出现故障等状态信息。

2、利用gossip 协议进行通信。过程如下：

* 每个节点都会单独开启一个TCP通道，用于节点之间的通信
* 每个节点在固定周期内通过特定规则选择几个节点发送ping
* 接收到ping消息的节点用pong 消息作为响应。

3、节点选择

频繁信息交换，势必加重带宽和计算的负担，所以选择一部分进行信息交换。

![](../.gitbook/assets/image%20%28102%29.png)



### 10.4 集群伸缩

1、集群伸缩=槽和数据在节点之间的移动

2、集群扩容的步骤：

* 准备新节点
* 加入集群
* 迁移槽和数据

3、收缩集群

![](../.gitbook/assets/image%20%28108%29.png)

### 10.5 请求路由

1、moved 重定向

![](../.gitbook/assets/image%20%28103%29.png)

2、键命令执行步骤

* 计算槽：哈希，然后取模。

  * 如果键内容包含{} 大括号字符，则计算槽的有效部分是括号内的内容，否则采用键的全内容计算槽。集群模式下mget 等命令优化批量调用时，键列表必须具有相同的slot, 否则会保存。

![](../.gitbook/assets/image%20%28106%29.png)

pipeline 同样受益于hash\_tag, 由于pipeline 只能向一个节点批量发送执行命令，而相同slot 必然会对应到唯一的节点，降低了集群使用pipeline 的门槛。

* 槽节点查找

每个节点中都包含了槽跟节点的映射关系。

![](../.gitbook/assets/image%20%28104%29.png)

* a

3、ASK 重定向

![](../.gitbook/assets/image%20%2898%29.png)

![](../.gitbook/assets/image%20%28105%29.png)

ASK 与moved 虽然都是对客户端的重定向控制，但是有本质的区别。ASK 重定向说明集群正在进行slot 数据迁移，客户端无法知道什么时候迁移完成，因此只是临时性的重定向。但是moved说明键对应的槽已经明确指定到新节点。



### 10.6 故障转移

当集群内少量节点出现故障时通过自动故障转移保证集群可以正常对外提供服务。

1、故障发现

分主观下线（单个节点任务不可用） 和 客观下线（多个节点都任务不可用）

2、故障恢复

![](../.gitbook/assets/image%20%28107%29.png)



## 11 缓存设计

### 11.1 缓存的收益和成本

1、收益

加速读写

降低后端负载

2、成本

* 数据不一致
* 代码维护成本
* 运维成本



### 11.2 缓存更新策略

1、LRU/LFU/FIFO 算法剔除

超过预设的最大值时，剔除

2、超时剔除



3、主动更新

对数据的一致性要求高，需要在真实数据更新后，立即更新缓存。

4、最佳建议

* 低一致性业务：建议配置最大内存和淘汰策略的方式使用
* 高一致性业务：可以结合超时剔除和主动更新，这样即使主动更新出了问题，也能保证数据过期后删除脏数据。

### 11.3 缓存粒度控制

从如下三个维度选择 全量缓存还是部分缓存：

* 通用性：缓存全部数据比部分数据更通用，但是从实际经验来看，一般只用几个字段；
* 空间占用：全部数据会浪费空间
* 代码维护：全部数据优势更加明显，部分数据维护不方便。

### 11.4 穿透优化

1、缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中，通常出于容错的考虑，如果从存储层查不到数据则不写入缓存层。

缓存穿透将导致不能存在的数据每次请求都要去存储层去查询， 失去了缓存保护后端存储的意义。

2、造成原因：（1）数据缺失不存在（2）恶意攻击

3、解决方案1：如果缓存层不命中，则缓存空对象。

缓存空对象的问题：

（1）空值做了缓存，意味着缓存中存储了更多的键，需要更多的内存空间（如果是攻击，问题更严重），比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除

（2）缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定的影响，此时要结合主动更新机制，如果存储层有数据了，需要及时清除掉缓存层中的空对象。

4、解决方案2：在访问缓存层和存储层之前，将存在的key 用布隆过滤器提前保存起来，做第一层拦截。

![](../.gitbook/assets/image%20%28117%29.png)



### 11.5 无底洞优化

数据存储在多个不同的节点，可能造成批量操作时，需要从不同节点上获取，相比于单机批量操作只涉及一次网络操作，分布式批量操作会涉及多次网络时间。

更多的的节点，并不代表更好的性能，所谓“无底洞”就是说投入越多不一定产出越多。

如果数据分布在不同的节点上，执行批量操作的几种形式：

（1）串行命令

逐次执行n个get 命令，它的操作时间： n次网络时间 + n 次命令。

![](../.gitbook/assets/image%20%28111%29.png)

（2）串行IO

先计算出每个node 的key 子列表，然后再执行n 次mget （每次mget 查一个node ）。

![](../.gitbook/assets/image%20%28114%29.png)

（3）并行IO

此是将方案2 中最后一步改为多线程执行，网络次数虽然还是节点个数，但是由于使用多线程，网络时间变为O\(1\).

![](../.gitbook/assets/image%20%28112%29.png)

\(4\) hash\_tag 实现

Redis Cluster 的hash\_tag 功能，可以将多个key 强制分配到一个节点上，它的操作时间=1次网络时间 + n 次命令时间。

![](../.gitbook/assets/image%20%28109%29.png)

![](../.gitbook/assets/image%20%28116%29.png)

### 11.6 雪崩优化

缓存雪崩：由于缓存层承担了大量请求，有效保护了存储层，但是如果由于缓存层由于某些原因不能提供服务，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会级联宕机的情况。

预防和解决缓存雪崩问题：

（1）保证缓存层服务高可用性

（2）依赖隔离组件为后端限流并降级

（3）提前演练

### 11.7 热点key 重建优化

1、如果有两个问题同时出现，可能会对应用造成致命的危害：

（1）当前key 是一个热点key ， 并发量非常大

（2）重建缓存不能在短时间内完成，可能是一个复杂计算。

在缓存失效的瞬间，有大量线程来重建缓存，造成后端负载过大，甚至出现可能会让应用崩溃。

减少同时重建缓存的方案：

（1）互斥锁：只允许一个线程重建缓存

（2）永远不过期：两层含义：

* 从缓存层面：确实没有设置过期时间，所以不会出现热点key  过期后产生的问题
* 从功能层面：为每个value 设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。

![](../.gitbook/assets/image%20%28110%29.png)



## 12 开发运维的坑

### 12.1 处理bigkey

1、bigkey 是指key 对应的value 所占的内存空间比较大。

（1）字符串类型：

单个value 值很大，一般超过10kb 就是bigkey.

（2）非字符串类型：

哈希、列表、集合、有序集合，体现在元素个数过多。

2、危害：

内存空间不均匀

超时阻塞：操作bigkey 比较耗时

网络阻塞：每次获取bigkey 产生的网络流量比较大

3、如何发现？

主动查找：通过指令去定期检查

被动发现：bigkey 导致慢查询或者网卡跑满问题，报警时排查。

4、如何删除？

不能一次性删除，得优雅删除。

每次获取一小部分，然后再删，逐渐循环。



### 12.2 寻找热点key

1、发现

（1）客户端

在客户端统计访问次数

（2）代理端

有些客户端的请求是通过代理端完成，可以在代理端做这个事情。

![](../.gitbook/assets/image%20%28113%29.png)

（3）Redis服务端

使用monitor 命令来统计。

（4）机器：

按照机器统计，然后加和。

2、解决

（1）拆分复杂数据结构

（2）迁移热点key：将热点key 迁移到一个单独的Redis集群上。

（3）本地缓存加通知机制：将热点key 放在业务端的本地缓存中。

