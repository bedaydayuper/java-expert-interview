# Redis开发与运维-note\(三\)

## 8 理解内存

### 8.1 内存消耗

1、内存消耗分为进程自身消耗和子进程消耗

![](../.gitbook/assets/image%20%2888%29.png)

2、对象内存：

```text
redis 内存占用最大的一块。
```

3、缓冲内存

主要包括：客户端缓冲、复制积压缓冲区、AOF缓冲区。

客户端缓冲：是指所有接入到Redis服务器TCP连接的输入输出缓冲。

复制积压缓冲区：该缓冲区用来实现部分复制功能

AOF缓冲区：用于在Redis重写期间保存最近写入的命令。

4、内存碎片：

内存分配器为了更好地管理和重复利用内存，分配内存策略一般采用固定范围的内存块进行分配。一般分配器都会有内存碎片。

内存碎片的解决办法：

（1）数据对齐

（2）安全重启：重启节点可以做到内存碎片重新整理。

5、子进程内存消耗

子进程内存消耗主要是指执行AOF/RDB重写时Redis创建的子进程内存消耗。



### 8.2 内存管理

Redis主要通过控制内存上限和回收策略实现内存管理。

#### 8.2.1 设置内存上限

只能限制实际使用的内存量，不包含内存碎片。



#### 8.2.2 回收

1、删除过期键对象

惰性删除

定时任务删除

2、内存溢出控制策略

当所用内存达到maxmemory 上限时，会触发相应的溢出控制策略。



### 8.3 内存优化

#### 8.3.1 redisObject 对象

![](../.gitbook/assets/image%20%2889%29.png)

type： 对外的5种类型

encoding：内部编码类型

lru：记录对象最后一次被访问的时间

refcount: 记录当前对象被引用的次数，当refcount=0时，被回收。

ptr：与对象的数据内容相关，如果是整数，直接存储数据；否则表示指向数据的指针。

#### 8.3.2 缩减键值对象

降低redis 内存使用最直接的方式就是缩减键和值的长度。

key 长度：在完整描述业务情况下，键值越短越好。

value 长度：可以采用压缩的方式存储。

#### 8.3.3 共享对象池

共享内存池是指Redis内部维护\[0-9999\] 的整数对象池，用于节约内存。因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。

为什么只有整数对象池？

> 首先整数对象池复用的几率最大，其次对象共享的一个关键操作就是判断相等性，Redis 之所以只有整数对象池，是因为整数比较算法为o\(1\),  只保留一万个整数为了防止对象池浪费。其他类型的比对，时间复杂度高。

#### 8.3.4 字符串优化

Redis 中值对象除了整数之外，都是使用的字符串存储。

1、字符串结构：

![](../.gitbook/assets/image%20%2890%29.png)

> O\(1\) 时间复杂度获取：字符串长度、已用长度、未用长度；
>
> 可用于保存字节数组，支持安全的二进制数据存储
>
> 内部实现空间预分配机制，降低内存再分配次数
>
> 惰性删除：字符串缩减后的空间不释放，作为预分配空间保留。

2、预分配机制

字符串之所以采用预分配的方式是防止修改操作需要不断重分配内存和字节数据拷贝。但同样也会造成内存的浪费。

字符串预分配每次并不都是翻倍扩容。

3、字符串重构

指不一定把每份数据作为字符串整体存储。同时，可以使用使用hmget/hmset 命令支持字段的部分读取修改，而不用每次整体存取。

#### 8.3.5 编码优化

通过不同的编码实现效率和空间的平衡。

#### 8.3.6 控制键的数量

比如 通过hash 和 ziplist 来减少key 的数量。就是使用hash 中的field 来减少key 的数量。



## 9 哨兵

### 9.1 基本原理

1、主从复制的问题

主负责写入，从节点分担主节点的读压力，并且在主节点挂掉之后，从节点晋升为主节点。

问题：

* 一旦主节点出现故障，需要手动将一个从节点晋升为主节点
* 主节点的写能力收到单机的限制
* 主节点的存储能力收到单机的限制

2、Redis sentinel 的高可用

当主节点出现故障时，Redis sentinel 能自动完成故障发现和故障转移，并通知应用方，从而实现真正的高可用。

Redis sentinel 是一个分布式架构，其中包含若干个sentinel节点和Redis数据节点，每个sentinel 节点会对数据节点和其余sentinel 节点进行监控，当它发现节点不可达时，会对节点做下线标识。如果被标识的是主节点，它还会和其他sentinel节点进行协商，当大多数sentinel节点都认为主节点不可达时，它们会选举出一个sentinel节点来完成自动故障转移的工作，同时会将这个变化实时通知给Redis应用方。



![](../.gitbook/assets/image%20%2892%29.png)

Redis sentinel 的作用：

* 监控
* 通知
* 主节点故障转移
* 配置提供者：客户端初始化的时候连接的是sentinel 节点集合。



### 9.2 实现原理

#### 9.2.1 三个定时监控任务

（1）每个10秒，每个sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构

![](../.gitbook/assets/image%20%2895%29.png)

（2）每隔2秒，每个sentinel节点会向Redis数据节点的_sentinel_:hello 频道上发送该sentinel 节点对于主节点的判断以及当前sentinel节点的信息，同时每个sentinel节点也会订阅该频道，来了解其他sentinel节点以及它们对主节点的判断。这个定时任务可以完成以下两个工作：

* 发现新的sentinel节点
* sentinel节点之间交换主节点的状态

![](../.gitbook/assets/image%20%2896%29.png)

（3）每隔1秒，每个sentinel节点会向主节点、从节点、其余sentinel节点发送一条ping 命令，进行一次心跳检测，来确认当前节点是否可达。

![](../.gitbook/assets/image%20%2893%29.png)

#### 9.2.2 主观下线和客观下线

主观下线：

sentinel 节点向其他节点发送心跳检测，如果其他节点在规定时间内没有返回，则sentinel节点就会对没有返回的节点做失败判定，这个行为叫做主观下线。主观下线是当前sentinel节点的一家之言，有误判的可能。

客观下线：

当sentinel主观下线的节点是主节点时，该sentinel 节点会向其他sentinel节点询问对主节点的判断，如果超过quorum个数，sentinel节点认为主节点确实有问题，这是该sentinel节点会做出客观下线的决定。

![](../.gitbook/assets/image%20%2894%29.png)



#### 9.2.3 领导者sentinel 节点选举

选出一个领导者sentinel节点，进行故障转移的工作。Redis采用raft算法实现领导者选举。

#### 9.2.4 故障转移

步骤：

* 在从节点中选一个作为新的主节点
* sentinel领导者节点会对第一步选出来的从节点执行slaveof no one 让其成为主节点
* sentinel领导者 向其他剩余的从节点发送命令，让他们成为新主节点的从节点
* sentinel节点集合会将原来的主节点更新为从节点，并保持对其关注，当其恢复后命令它去复制新的主节点。



![](../.gitbook/assets/image%20%2891%29.png)

## 10 集群



## 11 缓存设计



## 12 开发运维的坑

