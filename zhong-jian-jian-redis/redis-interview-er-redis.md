---
description: '参考 http://svip.iocoder.cn/Redis/Interview/'
---

# Redis interview\(二\) Redis  【转】

## 1 Redis 简介

Remote Dictionary Server.

### 1.1 优点

1 速度快：数据在内存中。

> Redis 本质上是一个 Key-Value 类型的内存数据库，很像 Memcached ，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。
>
> 因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value 数据库。

2 支持丰富数据类型

5种基础类型，然后还有高级的数据结构。

3、丰富的特性

订阅与发布

key 过期策略

事务

计数  
。。。

4、持久化存储

提供RDB 和 AOF 两种。

5、高可用

* 内置Redis sentinel，提供高可用方案，实现主从故障自动转移
* 内置Redis cluster， 提供集群方案，实现基于槽的分片方案，从而支持更大的Redis规模。

### 1.2 缺点

1、Redis 是内存数据库，要受限于机器的内存大小

2、修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久，这个过程中，Redis 不能提供服务。



## 2 Redis 线程模型

### 非阻塞IO,多路复用

> Redis 内部使用文件事件处理器 `file event handler`，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 Socket，根据 Socket 上的事件来选择对应的事件处理器进行处理。

文件事件处理器的结构包含 4 个部分：

* 多个 Socket 。
* IO 多路复用程序。
* 文件事件分派器。
* 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）。

多个 Socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。

![&#x5BA2;&#x6237;&#x7AEF;&#x4E0E; redis &#x7684;&#x4E00;&#x6B21;&#x901A;&#x4FE1;&#x8FC7;&#x7A0B;](../.gitbook/assets/image%20%28124%29.png)



* 客户端 Socket01 向 Redis 的 Server Socket 请求建立连接，此时 Server Socket 会产生一个 `AE_READABLE` 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给`连接应答处理器`。连接应答处理器会创建一个能与客户端通信的 Socket01，并将该 Socket01 的 `AE_READABLE` 事件与命令请求处理器关联。
* 假设此时客户端发送了一个 `set key value` 请求，此时 Redis 中的 Socket01 会产生 `AE_READABLE` 事件，IO 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事件，由于前面 Socket01 的 `AE_READABLE` 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 Scket01 的 `set key value` 并在自己内存中完成 `set key value` 的设置。操作完成后，它会将 Scket01 的 `AE_WRITABLE` 事件与令回复处理器关联。
* 如果此时客户端准备好接收返回结果了，那么 Redis 中的 Socket01 会产生一个 `AE_WRITABLE` 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 `ok`，之后解除 Socket01 的 `AE_WRITABLE` 事件与命令回复处理器的关联。



## 3 Redis单线程为什么这么快？

### 3.1 单线程为什么效率这么高？

1、纯内存操作

2、基于非阻塞的io多路复用机制

3、单线程，避免了多线程的频繁上下文切换问题

> Redis 利用队列技术，将并发访问变为串行访问，消除了传统数据库串行控制的开销。
>
> 实际上，Redis 4.0 开始，也开始有了一些异步线程，用于处理一些耗时操作。例如说，异步线程，实现[惰性删除](https://blog.csdn.net/zhanglong_4444/article/details/88350443)（解决大 KEY 删除，阻塞主线程）和异步 AOF （解决磁盘 IO 紧张时，fsync 执行一次很慢）等等。



### 3.2 Redis是单线程，如果提高多核CPU的利用率？

redis的读取和处理性能非常强大，一般服务器的cpu都不会是性能瓶颈。redis的性能瓶颈主要集中在内存和网络方面。所以，如果使用的redis命令多为O\(N\)、O\(log\(N\)\)时间复杂度，那么基本上不会出现cpu瓶颈的情况。 但是如果你确实需要充分使用多核cpu的能力，那么需要在单台服务器上运行多个redis实例\(主从部署/集群化部署\)，并将每个redis实例和cpu内核进行绑定\(使用 taskset命令，百度：[https://www.baidu.com/s?wd=taskset&tn=84053098\_3\_dg&ie=utf-8](https://www.baidu.com/s?wd=taskset&tn=84053098_3_dg&ie=utf-8)\)。  
如果需要进行集群化部署，你需要对redis进行分片存储，可以参考[https://redis.io/topics/partitioning](https://redis.io/topics/partitioning)

## 4 Redis 持久化

### 4.1 两种持久化方案 概述

* 1、【全量】RDB 持久化，是指在指定的时间间隔内将内存中的**数据集快照**写入磁盘。实际操作过程是，fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。
* 2、【增量】AOF持久化，以日志的形式记录服务器所处理的每一个**写、删除操作**，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。

### 4.2 RDB

#### 4.2.1 优缺点

① 优点

*  **灵活设置备份频率和周期**。你可能打算每个小时归档一次最近 24 小时的数据，同时还要每天归档一次最近 30 天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。
* **非常适合冷备份**，对于灾难恢复而言，RDB 是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。推荐，可以将这种完整的数据文件发送到一些远程的安全存储上去，比如说 Amazon 的 S3 云服务上去，在国内可以是阿里云的 OSS 分布式存储上。
* **性能最大化。**对于 Redis 的服务进程而言，在开始持久化时，它唯一需要做的只是 fork 出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行 IO 操作了。也就是说，RDB 对 Redis 对外提供的读写服务，影响非常小，可以让 Redis 保持高性能。
* **恢复更快。**相比于 AOF 机制，RDB 的恢复速度更更快，更适合恢复数据，特别是在数据集非常大的情况。

② 缺点

* 如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么 RDB 将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。
  * > 所以，RDB 实际场景下，需要和 AOF 一起使用。
* 由于 RDB 是通过 fork 子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是 1 秒钟。

### 4.3 AOF

① 优点

* 该机制可以带来更高的**数据安全性**，即数据持久性。Redis 中提供了 3 种同步策略，即每秒同步、每修改\(执行一个命令\)同步和不同步。
  * 事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。
  * 而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。
  * 至于不同步，无需多言，我想大家都能正确的理解它。
* 由于该机制对日志文件的写入操作采用的是 **append** 模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。
  * 因为以 append-only 模式写入，所以没有任何磁盘寻址的开销，写入性能非常高。
  * 另外，如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在 Redis 下一次启动之前，我们可以通过 redis-check-aof 工具来帮助我们解决数据一致性的问题。
* 如果 AOF 日志过大，Redis 可以自动启用 **rewrite** 机制。即使出现后台重写操作，也不会影响客户端的读写。因为在 rewrite log 的时候，会对其中的指令进行压缩，创建出一份需要恢复数据的最小日志出来。再创建新日志文件的时候，老的日志文件还是照常写入。当新的 merge 后的日志文件 ready 的时候，再交换新老日志文件即可。

  > 注意，AOF **rewrite** 机制，和 RDB 一样，也需要 fork 出一次子进程，如果 Redis 内存比较大，可能会因为 fork 阻塞下主进程。

* AOF 包含一个格式清晰、易于理解的日志文件用于记录所有的**修改操作**。事实上，我们也可以通过该文件完成数据的重建。



② 缺点

* 对于相同数量的数据集而言，AOF 文件通常要大于 RDB 文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。
* 根据同步策略的不同，AOF 在运行效率上往往会慢于 RDB 。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和 RDB 一样高效。
* 以前 AOF 发生过 bug ，就是通过 AOF 记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。所以说，类似 AOF 这种较为复杂的基于命令日志/merge/回放的方式，比基于 RDB 每次持久化一份完整的数据快照文件的方式，更加脆弱一些，容易有 bug 。不过 AOF 就是为了避免 rewrite 过程导致的 bug ，因此每次 rewrite 并不是基于旧的指令日志进行 merge 的，而是基于当时内存中的数据进行指令的重新构建，这样健壮性会好很多。

### 4.4 方案选择

bgsave 做镜像全量持久化，AOF 做增量持久化。因为 bgsave 会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要 AOF 来配合使用。在 Redis 实例重启时，会使用 bgsave 持久化文件重新构建内存，再使用 AOF 重放近期的操作指令来实现完整恢复重启之前的状态。



对方追问那如果突然机器掉电会怎样？取决于 AOF 日志 sync 属性的配置，如果不要求性能，在每条写指令时都 sync 一下磁盘，就不会丢失数据。但是在高性能的要求下每次都 sync 是不现实的，一般都使用定时 sync ，比如 1 秒 1 次，这个时候最多就会丢失 1 秒的数据。

对方追问 bgsave 的原理是什么？你给出两个词汇就可以了，fork 和 cow 。fork 是指 Redis 通过创建子进程来进行 bgsave 操作。cow 指的是 copy on write ，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。

## 5 Redis 过期策略

Redis 提供了 3 种数据过期策略：

* 被动删除：当读/写一个已经过期的 key 时，会触发惰性删除策略，直接删除掉这个过期 key 。
* 主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以 Redis 会定期主动淘汰一批已过期的 key 。
* 主动删除：当前已用内存超过 maxmemory 限定时，触发主动清理策略，即 [「数据“淘汰”策略」](http://svip.iocoder.cn/Redis/Interview/#) 。

## 6 Redis 淘汰策略

Redis 内存数据集大小上升到一定大小的时候，就会进行数据淘汰策略。

Redis 提供了 6 种数据淘汰策略：

1. volatile-lru
2. volatile-ttl
3. volatile-random
4. allkeys-lru
5. allkeys-random
6. 【默认策略】no-enviction

## 7 大量的 key 需要设置同一时间过期，一般需要注意什么？

如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，Redis可能会出现短暂的卡顿现象。

一般需要在时间上加一个随机值，使得过期时间分散一些。

## 8 Redis 客户端

Redis 官方推荐使用 Redisson 或 Jedis 。

Spring Boot 2.x 内置支持 Jedis 和 Lettuce 。一般情况下，建议：

* 使用 Spring Data Redis ，提供了透明使用 Jedis 和 Lettuce 的封装。也就是说，大多数时候，我们可以通过配置使用 Jedis 或 Lettuce 进行 Redis 的操作，而上层使用 Spring Data Redis 提供的统一 API 。
* 从目前来说，Jedis 会比 Lettuce 更加流行，并且更加稳定。虽然说 Jedis 有一段时间，不再进行更新，但是突然又开始更新，可能是诈尸了。
* 如果想要更加丰富的特性，例如说分布式锁，布隆过滤器，可以考虑研究下 Redisson 。

## 9 Redis 分布式锁

### 9.1 Redis分布式锁应该考虑的点

* 1、正确的获得锁

  > set 指令附带 nx 参数，保证有且只有一个进程获得到。

* 2、正确的释放锁

  > 使用 Lua 脚本，比对锁持有的是不是自己。如果是，则进行删除来释放。

* 3、超时的自动释放锁

  > set 指令附带 expire 参数，通过过期机制来实现超时释放。

* 4、未获得到锁的等待机制

  > sleep 或者基于 Redis 的订阅 Pub/Sub 机制。
  >
  > 一些业务场景，可能需要支持获得不到锁，直接返回 false ，不等待。

* 5、【可选】锁的重入性

  > 通过 ThreadLocal 记录是第几次获得相同的锁。
  >
  > 1）有且第一次计数为 1 && 获得锁时，才向 Redis 发起获得锁的操作。  
  > 2）有且计数为 0 && 释放锁时，才向 Redis 发起释放锁的操作。

* 6、锁超时的处理

  > 一般情况下，可以考虑告警 + 后台线程自动续锁的超时时间。通过这样的机制，保证有且仅有一个线程，正在持有锁。

* 7、Redis 分布式锁丢失问题

  > 具体看「方案二：Redlock」。

### 9.2 具体方案

#### 9.2.1 set 指令

先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。

当然，可以使用 `SET key value EX seconds NX` 命令，尝试获得锁。  一次完成setnx 跟 expire的操作。这样就避免setnx 之后，crash 了，锁得不到释放的问题。



#### 9.2.2 Redlock

set 指令的方案，适合用于在单机 Redis 节点的场景下，在多 Redis 节点的场景下，会存在分布式锁丢失的问题。所以，Redis 作者 Antirez 基于分布式环境下提出了一种更高级的分布式锁的实现方式：Redlock 。

流程图： [https://www.processon.com/view/link/5f4c871d079129356ec6f4d7](https://www.processon.com/view/link/5f4c871d079129356ec6f4d7)

文章：[https://mp.weixin.qq.com/s/JLEzNqQsx-Lec03eAsXFOQ](https://mp.weixin.qq.com/s/JLEzNqQsx-Lec03eAsXFOQ)



## 10 Redis pipeline

一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。



pipeline 是Redis client 实现的功能，而不是Redis server 的特性。

* 在使用 Pipeline 时，那么整个执行的顺序是，\[req1,req2,req3\] 一起发给 Redis Server ，而 Redis Server 收到请求后，一个一个请求进行执行，然后响应，不会进行什么特殊处理。而 Client 在收到 resp1,resp2,resp3 后，进行响应给业务上层。



**需要注意：并不是打包的命令越多越好，因为pipeline 要“独占”Redis，会hang住；另外结果是先存储到服务端，然后统一返回给client，如果指令比较多，这样对服务端内存消耗较大，并且网络传输的包也比较大。**

另外，批量执行多个指令，返回结果中，也是按照请求顺序拼装的结果。[https://www.jianshu.com/p/dfeac155adf8](https://www.jianshu.com/p/dfeac155adf8)  这里有个demo.

pipeline不是原子性的，中间可能会存在部分失败的情况，也就是说不能保证每条命令都能执行成功，如果中间有命令出现错误，redis不会中断执行，而是直接执行下一条命令，然后将所有命令的执行结果（执行成果或者执行失败）放到列表中统一返回，如果需要每条命令都执行成功，我们在批量执行过程中需要监控执行数量和返回的成功数量是否一致。

参考自： [https://blog.csdn.net/qq\_35923749/article/details/85252043](https://blog.csdn.net/qq_35923749/article/details/85252043)





## 11 Redis 事务

如果在EXEC指令被提交之前，Redis-server即检测到提交的某个指令存在语法错误，那么此事务将会被提前标记为DISCARD，此后事务提交也将直接被驳回； 如果在EXEC提交后，在实施数据变更时（Redis将不会预检测数据类型，比如你对一个“非数字”类型的key执行INCR操作），某条命令执行导致了ERROR，那么redis仍然不会回滚此前已经执行成功的操作，而且也不会中断ERROR之后的其他操作继续执行，这点是跟pipeline是一样的。所以对于我们开发者而言，我们需要关注事务执行后返回的结果（结果将是一个集合，按照操作提交的顺序排列，对于执行失败的操作，结果将是一个ERROR）。 



## 12 Redis 集群方案？

### 12.1 方案选择

* 1、Redis Sentinel

主从机制，上面的方案中主服务器可能存在单点故障，万一主服务器宕机，这是个麻烦事情，所以Redis提供了Redis-Sentinel，以此来实现主从切换的功能。



* 2、Redis Cluster

Redis 3.0集群采用了P2P的模式，完全去中心化。支持多节点数据集自动分片，提供一定程度的分区可用性，部分节点挂掉或者无法连接其他节点后，服务可以正常运行。Redis 3.0集群采用Hash Slot方案，而不是一致性哈希。Redis把所有的Key分成了16384个slot，每个Redis实例负责其中一部分slot。集群中的所有信息（节点、端口、slot等），都通过节点之间定期的数据交换而更新。



* 3、Twemproxy

Twemproxy是由Twitter开源的Redis代理， Redis客户端把请求发送到Twemproxy，Twemproxy根据路由规则发送到正确的Redis实例，最后Twemproxy把结果汇集返回给客户端。

Twemproxy通过引入一个代理层，将多个Redis实例进行统一管理，使Redis客户端只需要在Twemproxy上进行操作，而不需要关心后面有多少个Redis实例，从而实现了Redis集群。

但是，Twemproxy存在诸多不方便之处，最主要的是，Twemproxy无法平滑地增加Redis实例，业务量突增，需增加Redis服务器；业务量萎缩，需要减少Redis服务器。

* 4、Codis

Codis解决了Twemproxy的这两大痛点，由豌豆荚于2014年11月开源，基于Go和C开发、现已广泛用于豌豆荚的各种Redis业务场景。



### 12.2 方案选型原则

* 体量较小时，选择 Redis Sentinel ，单主 Redis 足以支撑业务。
* 体量较大时，选择 Redis Cluster ，通过分片，使用更多内存。

## 13 Redis 主从同步

### 

Redis 的主从同步\(replication\)机制，允许 Slave 从 Master 那里，通过网络传输拷贝到完整的数据备份，从而达到主从机制。

* 主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据。
* 一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。
* 第一次同步时，主节点做一次 bgsave 操作，并同时将后续修改操作记录到内存 buffer ，待完成后将 RDB 文件全量同步到复制节点，复制节点接受完成后将 RDB 镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。

**好处**

通过 Redis 的复制功，能可以很好的实现数据库的读写分离，提高服务器的负载能力。主数据库主要进行写操作，而从数据库负责读操作。



## 15 Redis cluster 实现高可用



### 15.1 Redis哈希槽

Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。

因为最大是 16384 个哈希槽，所以考虑 Redis 集群中的每个节点都能分配到一个哈希槽，所以最多支持 16384 个 Redis 节点。

为什么是 16384 呢？主要考虑集群内的网络带宽，而 16384 刚好是 2K 字节大小。

### 15.2 集群的主动复制模型



为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了**主从复制**模型，每个节点都会有 N-1 个复制节点。

所以，Redis Cluster 可以说是 Redis Sentinel 带分片的加强版。也可以说：

* Redis Sentinel 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master ，继续提供服务。
* Redis Cluster 着眼于扩展性，在单个 Redis 内存不足时，使用 Cluster 进行分片存储。

### 15.3 什么情况下导致整个集群不可用

有 A，B，C 三个节点的集群，在没有复制模型的情况下，如果节点 B 宕机了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。当然，这种情况也可以配置 `cluster-require-full-coverage=no` ，整个集群无需所有槽位覆盖。

### 15.4 集群会有写操作丢失吗？

Redis 并不能保证数据的强一致性，而是【异步复制】，这意味这在实际中集群在特定的条件下可能会丢失写操作。



## 16 Redis 健康指标

[https://mp.weixin.qq.com/s/D\_khsApGkRckEoV75pYpDA](https://mp.weixin.qq.com/s/D_khsApGkRckEoV75pYpDA)

* 存活情况
* 连接数
* 阻塞客户端数量
* 使用内存峰值
* 内存碎片率
* 缓存命中率
* OPS
* 持久化
* 失效KEY
* 慢日志

提高缓存命中率？ [https://www.cnblogs.com/shamo89/p/8383915.html](https://www.cnblogs.com/shamo89/p/8383915.html)

> 尽可能的聚焦在高频访问且时效性要求不高的热点业务上（如字典数据、session、token），通过缓存预加载（预热）、增加存储容量、调整缓存粒度、更新缓存等手段来提高命中率。

## 17 优化Redis 内存占用



**假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？**

使用 `keys` 指令可以扫出指定模式的 key 列表。

* 对方接着追问：如果这个 Redis 正在给线上的业务提供服务，那使用 `keys` 指令会有什么问题？
* 这个时候你要回答 Redis 关键的一个特性：Redis 的单线程的。`keys` 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 `scan` 指令，`scan` 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 `keys` 指令长。

## 18 Redis 常见性能问题与解决





