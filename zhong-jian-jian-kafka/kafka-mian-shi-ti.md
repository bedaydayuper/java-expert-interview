# kafka-面试题一、消息队列

## 1 消息队列的用途？

主要用于应用解耦、异步消息、流量削锋、消息通讯、日志处理等问题。

### 1.1 应用解耦

传统模式：

![](../.gitbook/assets/image%20%2865%29.png)

引入消息队列之后：

![](../.gitbook/assets/image%20%2864%29.png)

有了消息队列，从主动调用的方式，变成了消息的订阅发布，从而解耦。

### 1.2 异步消息

不过，使用消息队列进行异步处理，会有一个前提，返回的结果不依赖于处理的结果。

传统：

![](../.gitbook/assets/image%20%2862%29.png)

消息队列：

![](../.gitbook/assets/image%20%2869%29.png)

### 1.3 流量削锋

传统：

![](../.gitbook/assets/image%20%2870%29.png)

消息队列：

![](../.gitbook/assets/image%20%2868%29.png)

### 1.4 日志处理

![](../.gitbook/assets/image%20%2856%29.png)

```text
日志采集客户端，负责日志数据采集，定时批量写入 Kafka 队列。
Kafka 消息队列，负责日志数据的接收，存储和转发。
日志处理应用：订阅并消费 Kafka 队列中的日志数据。
```



## 2 消息队列的缺点：

### 2.1 系统可用性降低

系统引入外部依赖越多，越容易挂掉。引入了消息队列，就要考虑消息队列的可用性。

### 2.2 系统复杂度提高

需要多考虑：

```text
1、重复消费怎么办？
2、怎么保证消息不丢失
3、需要消息顺序的业务场景怎么办？
```

### 2.3 一致性问题

特别是使用消息队列用作异步处理，需要达到最终一致性。



## 3 消息队列的组成？

![](../.gitbook/assets/image%20%2858%29.png)

producer  
consumer  
broker： 消息代理，负责存储消息和转发消息。

## 4 消费语义

### 4.1 消息至多被消费一次

适合能容忍丢失消息的场景。

```text
1、Producer 发送消息到 Message Broker 阶段
Producer 发消息给Message Broker 时，
不要求 Message Broker 对接收到的消息响应确认，
Producer 也不用关心 Message Broker 是否收到消息了。
2、Message Broker 存储/转发阶段
对 Message Broker 的存储不要求持久性。
转发消息时，也不用关心 Consumer 是否真的收到了。
3、Consumer 消费阶段
Consumer 从 Message Broker 中获取到消息后，可以从 Message Broker 删除消息。
或 Message Broker 在消息被 Consumer 拿去消费时删除消息，不用关心 Consumer 最后对消息的消费情况如何。
```

### 4.2 消息至少被消费一次

适合不能容忍丢消息，允许重复消费的任务。

```text
1、Producer 发送消息到 Message Broker 阶段
Producer 发消息给 Message Broker ，Message Broker 必须响应对消息的确认。
2、Message Broker 存储/转发阶段
Message Broker 必须提供持久性保障。
转发消息时，Message Broker 需要 Consumer 通知删除消息，才能将消息删除。
3、Consumer消费阶段
Consumer 从 Message Broker 中获取到消息，必须在消费完成后，Message Broker上的消息才能被删除。
```

### 4.3 消息仅被消费一次

适合对消息消费情况要求非常高的任务，实现较为复杂。

#### 4.3.1 broker上存储的消息被consumer仅消费一次

1、producer --&gt; broker

producer 不关心broker是否收到消息，也不要求broker 收到消息之后确认。

2、broker 存储转发阶段

必须提供持久化保证。

每条消息都有唯一标识

3、broker--&gt; consumer 消费  
consumer  消费之后，必须记下标识，防止重复消费。



#### 4.3.2 producer 上产生的消息被consumer仅消费一次

1、producer --&gt; broker  
broker 必须响应生产者的消息，并且producer负责为该消息产生唯一标识，以防止consumer重复消费。

2、broker 存储转发阶段  
必须提供持久化保证。

每条消息都有唯一标识

3、broker--&gt; consumer 消费  
consumer  消费之后，必须记下标识，防止重复消费。

## 5 消息队列的投递方式

push:

```text
优点：
及时
缺点：
受限于消费者的消费能力，可能造成消息的堆积，broker 会不断给消费者发送不能处理的消息。
```

pull:

```text
优点：
主动权掌握在消费方，可以根据自己的消费速度进行消息拉取。
缺点：
消费方不知道什么时候可以获取最新的消息，会有消息延迟和忙等待。
```

目前的方式：  
基于push + pull 模式结合的方式，broker仅仅告诉consumer 有新的消息（push）, 而具体消息拉取，还是consumer 自己主动拉取。

## 6 如何保证消费者消费消息的幂等性？

### 6.1 框架层统一封装

```text
首先，需要有一个消息排重的唯一标识，只能由producer生成，比如uuid, snowflake;
然后，需要一个排重的存储器（如MySQL 的唯一索引 来保证）

如何插入这条排重记录到存储器中？
方案一、在消费执行之前，但是如果消费者崩溃了，这条消息就无法被消费了。
方案二、在消费执行之后：
（1）如果消费失败，这条消息后续会继续被重试消费
（2）如果消费成功，此时插入记录，但是如果插入记录失败怎么办？
那就需要插入记录和业务逻辑放在同一个事务中。
```

### 6.2 业务层自己实现

```text
先查数据库，如果被消费过，则直接返回消费完成，否则执行消费
更新数据库时，带上数据的状态。
```

### 6.3 方案选择

```text
正常情况下，出现重复消息的概率其实很小，
如果由框架层统一封装来实现的话，肯定会对消息系统的吞吐量和高可用有影响，
所以最好还是由业务层自己实现处理消息重复的问题。
```

##  7 如何保证生产者的发送消息的可靠性？

不同的消息队列机制不同。下面主要总结kafka 的机制：



## 8 如何保证消息的顺序性？

不同的消息队列机制不同。下面主要总结kafka 的机制：



## 9 如何解决消息积压的问题？

todo

## 10 如何解决消息过期的问题？

todo

## 11 消息队列如何实现高可用？

不同的消息队列机制不同。下面主要总结kafka 的机制：

## 12 常用消息队列的比对

![](../.gitbook/assets/image%20%2863%29.png)

## 13 消息队列的一般存储方式有哪些？

KV 

```text
由于分布式缓存的读写能力要优于 DB ，所以在对消息的读写能力要求都不是比较高的情况下，
采用这种方式倒也不失为一种可以替代的设计方案。

消息存储于分布式 KV 需要解决的问题在于如何保证 MQ 整体的可靠性。
```

文件系统

```text
消息刷盘为消息存储提供了一种高效率、高可靠性和高性能的数据持久化方式。
除非部署 MQ 机器本身或是本地磁盘挂了，否则一般是不会出现无法持久化的故障问题。
```

关系型数据库

```text
由于，普通关系型数据库（如 MySQL ）在单表数据量达到千万级别的情况下，
其 IO 读写性能往往会出现瓶颈。
因此，如果要选型或者自研一款性能强劲、吞吐量大、消息堆积能力突出的 MQ 消息队列，
那么并不推荐采用关系型数据库作为消息持久化的方案。
在可靠性方面，该种方案非常依赖 DB ，如果一旦 DB 出现故障，则 MQ 的消息就无法落盘存储会导致线上故障。
```

## 14 如何自己设计消息队列？

todo



## 疑问

1、kafka  在如下几个方面，是如何保证的？  
消息不丢失、消息不重复、消费者幂等、生产者可靠、消息有序、消息积压如何解决、消息过期如何解决、如何实现高可用、存储方式是什么



## 参考

[http://svip.iocoder.cn/MQ/Interview/](http://svip.iocoder.cn/MQ/Interview/)  




## 



